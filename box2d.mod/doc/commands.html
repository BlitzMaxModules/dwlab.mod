<html><head><title>Box2D reference</title>
<link rel=stylesheet Type=text/css href='../../../../doc/bmxstyle.css'>
</head><body>
<table width=100% cellspacing=0><tr align=center><td class=small>&nbsp;</td>
<td class=small width=1%><b>dwlab.Box2D:</b></td>
<td class=small width=1%><a href=#functions class=small>Functions</a></td>
<td class=small width=1%><a href=#types class=small>Types</a></td>
<td class=small width=1%><a href=#modinfo class=small>Modinfo</a></td>
<td class=small width=1%><a href='../../../../mod/dwlab.mod/box2d.mod/box2d.bmx' class=small>Source</a></td>
<td class=small>&nbsp;</td></tr></table>
<h1>Box2D</h1>
<link rel="stylesheet" href="manual.css" type="text/css">
<a href="www.box2d.org/"><img src="box2d_logo.gif" align="right" border="0" /></a>
<p>
Box2D is a 2D rigid body simulation library for games. It can be used to make objects move in believable ways and make the world seem more interactive. From the game's point of view a physics engine is just a system for procedural animation. Rather than paying (or begging) an animator to move your actors around, you can let Sir Isaac Newton do the directing.
</p>
<p>
BaH.Box2D is a BlitzMax language binding (wrapper) of the Box2D library. The documentation is derived from Box2D's accompanying manual and API guide, by Erin Catto.
</p>
<p>
	<b>Table of Contents</b>
</p>
<dl>
	<dt>
		<span class="chapter">
			<a href="#d0e15">1. Introduction</a>
		</span>
	</dt>
	<dd>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e28">1.1. Prerequisites</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e44">1.2. Core Concepts</a>
				</span>
			</dt>
		</dl>
	</dd>
	<dt>
		<span class="chapter">
			<a href="#d0e110">2. Hello Box2D</a>
		</span>
	</dt>
	<dd>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e118">2.1. Creating a World</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e143">2.2. Creating a Ground Box</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e203">2.3. Creating a Dynamic Body</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e227">
						2.4. Simulating the World (of Box2D)
					</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e257">2.5. Cleanup</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e265">2.6. The Examples</a>
				</span>
			</dt>
		</dl>
	</dd>
	<dt>
		<span class="chapter">
			<a href="#d0e305">3. API Design</a>
		</span>
	</dt>
	<dd>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e308">3.1. Memory Management</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e348">3.2. Factories and Definitions</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#units">3.3. Units</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e397">3.4. User Data</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e451">3.5. Strawman</a>
				</span>
			</dt>
		</dl>
	</dd>
	<dt>
		<span class="chapter">
			<a href="#d0e459">4. The World</a>
		</span>
	</dt>
	<dd>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e462">4.1. About</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e473">
						4.2. Creating and Destroying a World
					</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e496">4.3. Using a World</a>
				</span>
			</dt>
			<dd>
				<dl>
					<dt>
						<span class="sect2">
							<a href="#d0e504">4.3.1. Simulation</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e517">
								4.3.2. Exploring the World
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e544">4.3.3. AABB Queries</a>
						</span>
					</dt>
				</dl>
			</dd>
		</dl>
	</dd>
	<dt>
		<span class="chapter">
			<a href="#d0e560">5. Bodies</a>
		</span>
	</dt>
	<dd>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e563">5.1. About</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e575">5.2. Body Definition</a>
				</span>
			</dt>
			<dd>
				<dl>
					<dt>
						<span class="sect2">
							<a href="#d0e587">5.2.1. Mass Properties</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e612">
								5.2.2. Position and Angle
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e635">5.2.3. Damping</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e649">
								5.2.4. Sleep Parameters
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#bullets">5.2.5. Bullets</a>
						</span>
					</dt>
				</dl>
			</dd>
			<dt>
				<span class="sect1">
					<a href="#d0e683">5.3. Body Factory</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e720">5.4. Using a Body</a>
				</span>
			</dt>
			<dd>
				<dl>
					<dt>
						<span class="sect2">
							<a href="#d0e725">5.4.1. Mass Data</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e740">
								5.4.2. State Information
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e753">
								5.4.3. Position and Velocity
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e768">
								5.4.4. Forces and Impulses
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e779">
								5.4.5. Coordinate Transformations
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e786">5.4.6. Lists</a>
						</span>
					</dt>
				</dl>
			</dd>
		</dl>
	</dd>
	<dt>
		<span class="chapter">
			<a href="#shapes">6. Shapes</a>
		</span>
	</dt>
	<dd>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e798">6.1. About</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e807">6.2. The Shape Definition</a>
				</span>
			</dt>
			<dd>
				<dl>
					<dt>
						<span class="sect2">
							<a href="#d0e815">
								6.2.1. Friction and Restitution
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e837">6.2.2. Density</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e845">6.2.3. Filtering</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e889">6.2.4. Sensors</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e898">
								6.2.5. Circle Definitions
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e910">
								6.2.6. Polygon Definitions
							</a>
						</span>
					</dt>
				</dl>
			</dd>
			<dt>
				<span class="sect1">
					<a href="#d0e950">6.3. Shape Factory</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e976">6.4. Using a Shape</a>
				</span>
			</dt>
		</dl>
	</dd>
	<dt>
		<span class="chapter">
			<a href="#d0e984">7. Joints</a>
		</span>
	</dt>
	<dd>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e987">7.1. About</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e996">7.2. The Joint Definition</a>
				</span>
			</dt>
			<dd>
				<dl>
					<dt>
						<span class="sect2">
							<a href="#d0e1018">7.2.1. Distance Joint</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1034">7.2.2. Revolute Joint</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1077">
								7.2.3. Prismatic Joint
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1097">7.2.4. Pulley Joint</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1123">7.2.5. Gear Joint</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1150">7.2.6. Mouse Joint</a>
						</span>
					</dt>
				</dl>
			</dd>
			<dt>
				<span class="sect1">
					<a href="#d0e1155">7.3. Joint Factory</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e1187">7.4. Using Joints</a>
				</span>
			</dt>
			<dd>
				<dl>
					<dt>
						<span class="sect2">
							<a href="#d0e1200">
								7.4.1. Using Distance Joints
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1205">
								7.4.2. Using Revolute Joints
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1226">
								7.4.3. Using Prismatic Joints
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1233">
								7.4.4. Using Pulley Joints
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1240">
								7.4.5. Using Gear Joints
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1248">
								7.4.6. Using Mouse Joints
							</a>
						</span>
					</dt>
				</dl>
			</dd>
		</dl>
	</dd>
	<dt>
		<span class="chapter">
			<a href="#d0e1253">8. Contacts</a>
		</span>
	</dt>
	<dd>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e1256">8.1. About</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e1310">8.2. Contact Listener</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e1359">8.3. Contact Filtering</a>
				</span>
			</dt>
		</dl>
	</dd>
	<dt>
		<span class="chapter">
			<a href="#d0e1390">9. Loose Ends</a>
		</span>
	</dt>
	<dd>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#world_boundary">9.1. World Boundary</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#implicit_destruction">
						9.2. Implicit Destruction
					</a>
				</span>
			</dt>
		</dl>
	</dd>
	<dt>
		<span class="chapter">
			<a href="#d0e1465">10. Settings</a>
		</span>
	</dt>
	<dd>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e1468">10.1. About</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e1481">10.2. Tolerances</a>
				</span>
			</dt>
		</dl>
	</dd>
	<dt>
		<span class="chapter">
			<a href="#d0e1513">11. Debug Drawing</a>
		</span>
	</dt>
</dl>
</div>
<div class="chapter" lang="en">
	<div class="titlepage">
		<div>
			<div>
				<h2 class="title">
					<a name="d0e15"></a>
					Chapter 1. Introduction
				</h2>
			</div>
		</div>
	</div>
	<div class="toc">
		<p>
			<b>Table of Contents</b>
		</p>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e28">1.1. Prerequisites</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e44">1.2. Core Concepts</a>
				</span>
			</dt>
		</dl>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e28"></a>
						1.1. Prerequisites
					</h2>
				</div>
			</div>
		</div>
		<p>
			In this manual it is assumed you are familiar with basic
			physics concepts, such as mass, force, torque, and impulses.
			If not, please first consult the many tutorials provided by
			Chris Hecker and David Baraff (google these names). You do
			not need to understand their tutorials in great detail, but
			they do a good job of laying out the basic concepts that
			will help you use Box2D.
		</p>
		<p>
			<a href="http://wikipedia.org" target="_top">Wikipedia</a>
			is also an excellent source of physics and mathematics
			knowledge. In some ways it is more useful than Google,
			because it has carefully crafted content.
		</p>
		<p>
			This is not a prerequisite, but if you are curious about the
			about the inner workings of Box2D, you can look at these
			<a href="http://www.gphysics.com/downloads" target="_top">
				articles
			</a>
			.
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e44"></a>
						1.2. Core Concepts
					</h2>
				</div>
			</div>
		</div>
		<p>
			Box2D works with several fundamental objects. We briefly
			define these objects here and more details are given later
			in this document.
		</p>
		<div class="glosslist">
			<dl>
				<dt>rigid body</dt>
				<dd>
					<p>
						A chunk of matter that is so strong that the
						distance between any two bits of matter on the
						chunk is completely constant. They are hard like
						a diamond. In the following discussion we use
						<span class="emphasis">
							<em>body</em>
						</span>
						interchangably with rigid body.
					</p>
				</dd>
				<dt>shape</dt>
				<dd>
					<p>
						A 2D piece of collision geometry that is rigidly
						attached to a body. Shapes have material
						properties of friction and restitution.
					</p>
				</dd>
				<dt>constraint</dt>
				<dd>
					<p>
						A constraint is a physical connection that
						removes degrees of freedom from bodies. In 2D a
						body has 3 degrees of freedom. If we take a body
						and pin it to the wall (like a pendulum) we have
						<span class="emphasis">
							<em>constrained</em>
						</span>
						the body to the wall. At this point the body can
						only rotate about the pin, so the constraint has
						removed 2 degrees of freedom.
					</p>
				</dd>
				<dt>contact constraint</dt>
				<dd>
					<p>
						A special constraint designed to prevent
						penetration of rigid bodies and to simulate
						friction and restitution. You will never create
						a contact constraint, they are created
						automatically by Box2D.
					</p>
				</dd>
				<dt>joint</dt>
				<dd>
					<p>
						This is a contraint used to hold two or more
						bodies together. Box2D supports these joint
						types: revolute, prismatic, distance, and more.
						Joints may support
						<span class="emphasis">
							<em>limits</em>
						</span>
						and
						<span class="emphasis">
							<em>motors</em>
						</span>
						.
					</p>
				</dd>
				<dt>joint limit</dt>
				<dd>
					<p>
						A joint limit restricts the range of motion of a
						joint. For example, the human elbow only allows
						a certain range of angles.
					</p>
				</dd>
				<dt>joint motor</dt>
				<dd>
					<p>
						A joint motor drives the motion of the connected
						bodies according to the joint's degrees of
						freedom. For example, you can use a motor to
						drive the rotation of an elbow.
					</p>
				</dd>
				<dt>world</dt>
				<dd>
					<p>
						A physics world is a collection of bodies,
						shapes, and constraints that interact together.
						Box2D supports the creation of multiple worlds,
						but this is usually not necessary or desirable.
					</p>
				</dd>
			</dl>
		</div>
	</div>
</div>
<div class="chapter" lang="en">
	<div class="titlepage">
		<div>
			<div>
				<h2 class="title">
					<a name="d0e110"></a>
					Chapter 2. Hello Box2D
				</h2>
			</div>
		</div>
	</div>
	<div class="toc">
		<p>
			<b>Table of Contents</b>
		</p>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e118">2.1. Creating a World</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e143">2.2. Creating a Ground Box</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e203">2.3. Creating a Dynamic Body</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e227">
						2.4. Simulating the World (of Box2D)
					</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e257">2.5. Cleanup</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e265">2.6. The Examples</a>
				</span>
			</dt>
		</dl>
	</div>
	<p>
		In the distribution of Box2D is a
		<span class="emphasis">
			<em>Hello World</em>
		</span>
		project. The program creates a large ground box and a small
		dynamic box. This code does not contain any graphics, so prepare
		to be underwelmed. :)
	</p>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e118"></a>
						2.1. Creating a World
					</h2>
				</div>
			</div>
		</div>
		<p>
			Every Box2D program begins with the creation of a world
			object. This is the physics hub that manages memory,
			objects, and simulation.
		</p>
		<p>
			To create a world object, first we need to define a bounding
			box for the world. Box2D uses the bounding box to accelerate
			collision detection. The size isn't critical, but a better
			fit will improve performance. It is better to make the box
			too big than to make it too small.
		</p>
		<pre class="programlisting">
Local worldAABB:b2AABB = New b2AABB
worldAABB.SetLowerBound(-100.0, -100.0)
worldAABB.SetUpperBound(100.0, 100.0)
		</pre>
		<div class="caution"
			style="margin-left: 0.5in; margin-right: 0.5in;">
			<h3 class="title">Caution</h3>
			<p>
				The
				<span class="emphasis">
					<em>world AABB</em>
				</span>
				should always be bigger then the region where your
				bodies are located. It is better to make the world AABB
				too big than too small. If a body reaches the boundary
				of the world AABB it will be frozen and will stop
				simulating.
			</p>
		</div>
		<p>
			Next we define the gravity vector. Yes, you can make gravity
			go sideways (or you could just rotate your monitor). Also we
			tell the world to allow bodies to sleep when they come to
			rest. A sleeping body doesn't require any simulation.
		</p>
		<pre class="programlisting">
Local gravity:b2Vec2 = New b2Vec2.Create(0.0, -10.0)
Local doSleep:int = true
		</pre>
		<p>
			Now we create the world object. Normally you would create
			the world on the heap and store the pointer in one of your
			game structures. However, creating the world on the stack
			works fine in this example.
		</p>
		<pre class="programlisting">
Local world:b2World = New b2World.Create(worldAABB, gravity, doSleep)
		</pre>
		<p>
			So now we have our physics world, let's start adding some
			stuff to it.
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e143"></a>
						2.2. Creating a Ground Box
					</h2>
				</div>
			</div>
		</div>
		<p>Bodies are built using the following steps:</p>
		<div class="orderedlist">
			<ol type="1">
				<li>
					<p>Define a body with a position, damping, etc.</p>
				</li>
				<li>
					<p>Use the world object to create the body.</p>
				</li>
				<li>
					<p>
						Define shapes with geometry, friction, density,
						etc.
					</p>
				</li>
				<li>
					<p>Create shapes on the body.</p>
				</li>
				<li>
					<p>
						Optionally adjust the body's mass to match the
						attached shapes.
					</p>
				</li>
			</ol>
		</div>
		<p>
			For step 1 we create the ground body. For this we need a
			<span class="emphasis">
				<em>body definition</em>
			</span>
			. With the body definition we specify the initial position
			of the ground body.
		</p>
		<pre class="programlisting">
Local groundBodyDef:b2BodyDef = New b2BodyDef
groundBodyDef.SetPositionXY(0.0, -10.0)
		</pre>
		<p>
			For step 2 the body definition is passed to the world object
			to create the ground body. The world object does not keep a
			reference to the body definition. The ground body is created
			as a static body. Static bodies don't collide with other
			static bodies and are immovable. Box2D determines that a
			body is static when it has zero mass. Bodies have zero mass
			by default, therefore they are static by default.
		</p>
		<pre class="programlisting">
Local groundBody:b2Body = world.CreateBody(groundBodyDef)
		</pre>
		<p>
			For step 3 we create a ground polygon definition. We use the
			<tt class="literal">SetAsBox</tt>
			shortcut to form the ground polygon into a box shape, with
			the box centered on the origin of the parent body.
		</p>
		<pre class="programlisting">
Local groundShapeDef:b2PolygonDef = New b2PolygonDef
groundShapeDef.SetAsBox(50.0, 10.0)
		</pre>
		<p>
			The
			<tt class="function">SetAsBox</tt>
			function takes the half-width and half-height. So in this
			case the ground box is 100 units wide (x-axis) and 20 units
			tall (y-axis). Box2D is tuned for meters, kilograms, and
			seconds. So you can consider the extents to be in meters.
			However, it is possible to change unit systems, as discussed
			later in this document
		</p>
		<p>
			We finish the ground body in step 4 by creating the ground
			polygon shape on the ground body.
		</p>
		<pre class="programlisting">
groundBody.CreateShape(groundShapeDef)
		</pre>
		<p>
			Again, Box2D does not keep a reference to the shape or body
			definitions. It copies the data into the
			<tt class="classname">b2Body</tt>
			structure.
		</p>
		<p>
			Note that every shape must have a parent body, even shapes
			that are static. However, you can attach all static shapes
			to a single static body. This need for static bodies is done
			to make the Box2D code more uniform internally, reducing the
			number of potential bugs.
		</p>
		<p>
			You might notice a pattern here. Most Box2D types are
			prefixed with
			<tt class="literal">b2</tt>
			. This is done to reduce the chance for naming conflicts
			with your code.
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e203"></a>
						2.3. Creating a Dynamic Body
					</h2>
				</div>
			</div>
		</div>
		<p>
			So now we have a ground body. We can use the same technique
			to create a dynamic body. The main difference, besides
			dimensions, is that we must establish the dynamic body's
			mass properties.
		</p>
		<p>
			First we create the body using
			<tt class="function">CreateBody</tt>
			.
		</p>
		<pre class="programlisting">
Local bodyDef:b2BodyDef = new b2BodyDef
bodyDef.SetPositionXY(0.0, 4.0)
Local body:b2Body = world.CreateBody(bodyDef)
		</pre>
		<p>
			Next we create and attach a polygon shape. Notice that we
			set density to 1. The default density is zero. Also, the
			friction on the shape is set to 0.3. Once the shape is
			attached, we instruct the body to compute it's mass
			properties from the attached shapes using the method
			<tt class="function">SetMassFromShapes</tt>
			. This gives you a hint that you can attach more than one
			shape per body. If the computed mass is zero, then the body
			becomes truly static. Bodies have a mass of zero by default,
			that's why we didn't need to call
			<tt class="function">SetMassFromShapes</tt>
			for the ground body.
		</p>
		<pre class="programlisting">
Local shapeDef:b2PolygonDef = New b2PolygonDef
shapeDef.SetAsBox(1.0, 1.0)
shapeDef.SetDensity(1.0)
shapeDef.SetFriction(0.3)
body.CreateShape(shapeDef)
body.SetMassFromShapes()
		</pre>
		<p>
			That's it for initialization. We are now ready to begin
			simulating.
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e227"></a>
						2.4. Simulating the World (of Box2D)
					</h2>
				</div>
			</div>
		</div>
		<p>
			So we have initialized the ground box and a dynamic box. Now
			we are ready to set Newton loose to do his thing. We just
			have a couple more issues to consider.
		</p>
		<p>
			Box2D uses a bit of numerical code called an
			<span class="emphasis">
				<em>integrator</em>
			</span>
			. Integrators simulate the physics equations at discrete
			points of time. This goes along with the traditional game
			loop where we essentially have a flip book of movement on
			the screen. So we need to pick a time step for Box2D.
			Generally physics engines for games like a time step at
			least as fast as 60Hz or 1/60 seconds. You can get away with
			larger time steps, but you will have to be more careful
			about setting up the definitions for your world. We also
			don't like the time step to change much. So don't tie the
			time step to your frame rate (unless you really, really have
			to). Without further ado, here is the time step.
		</p>
		<pre class="programlisting">
Local timeStep:Float = 1.0 / 60.0
		</pre>
		<p>
		In addition to the integrator, Box2D also uses a larger bit
		of code called a <span class="emphasis"><em>constraint solver</em></span>.
		The constraint solver solves all the constraints in the simulation, one
		at a time. A single constraint can be solved perfectly. However, when we
		solve one constraint, we slightly disrupt other constraints. To get a good
		solution, we need to iterate over all constraints a number of times.
		</p>
		<p>
		There are two phases in the constraint solver: a velocity phase and a
		position phase. In the velocity phase the solver computes the impulses
		necessary for the bodies to move correctly. In the position phase the
		solver adjusts the positions of the bodies to reduce overlap and joint
		detachment. Each phase has its own iteration count. In addition, the
		position phase will exit iteraions early if the errors are small.
		</p>
		<p>
		The suggested iteration count for Box2D is 10 for both velocity and
		position. You can tune this number to your liking, just keep in mind
		that this has a trade-off between speed and accuracy. Using fewer
		iterations increases performance but accuracy suffers. Likewise, using
		more iterations decreases performance but improves the quality of your
		simulation. For this simple example, we don't need many iterations.
		Here are our chosen iteration counts.
		</p>
		<pre class="programlisting">
Local velocityIterations:Int = 8
Local positionIterations:Int = 1
		</pre>
		<p>
		Note that the time step and the iteration count are completely
		unrelated. An iteration is not a sub-step. One iteration is a single
		pass over all the constraints withing a time step. You can have multiple
		passes over the constraints within a single time step.
		</p>
		<p>
		We are now ready to begin the simulation loop. In your game the
		simulation loop can be merged with your game loop. In each pass through
		your game loop you call <tt class="literal">b2World::Step</tt>. Just
		one call is usually enough, depending on your frame rate and your
		physics time step.
		</p>
		<p>
		The Hello World program was designed to be dead simple, so it has
		no graphical output. Rather that being utterly boring by producing
		no output, the code prints out the position and rotation of the dynamic
		body. Yay! Here is the simulation loop that simulates 60 time steps
		for a total of 1 second of simulated time.
		</p>
<pre class="programlisting">
For Local i:Int = 0 Until 60
	world.DoStep(timeStep, velocityIterations, positionIterations)
	Local position:b2Vec2 = body.GetPosition()
	Local angle:Float = body.GetAngle()
	Print position.X() + " " + position.Y() + " " + angle
Next
		</pre>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e257"></a>
						2.5. Cleanup
					</h2>
				</div>
			</div>
		</div>
		<p>
			When a world leaves scope or is deleted by calling
			<tt class="literal">delete</tt>
			on a pointer, all the memory reserved for bodies and joints
			is freed. This is done to make your life easier. However,
			you will need to nullify any body, shape, or joint pointers
			you have because they will become invalid.
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e265"></a>
						2.6. The Examples
					</h2>
				</div>
			</div>
		</div>
		<p>
			Once you have conquered the HelloWorld example, you should
			start looking at Box2D's examples. 
		</p>
		<p>
			The testbed has many examples of Box2D usage in the test
			cases and the framework itself. I encourage you to explore
			and tinker with the testbed as you learn Box2D.
		</p>
	</div>
</div>
<div class="chapter" lang="en">
	<div class="titlepage">
		<div>
			<div>
				<h2 class="title">
					<a name="d0e305"></a>
					Chapter 3. API Design
				</h2>
			</div>
		</div>
	</div>
	<div class="toc">
		<p>
			<b>Table of Contents</b>
		</p>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e308">3.1. Memory Management</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e348">3.2. Factories and Definitions</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#units">3.3. Units</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e397">3.4. User Data</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e451">3.5. Strawman</a>
				</span>
			</dt>
		</dl>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e308"></a>
						3.1. Memory Management
					</h2>
				</div>
			</div>
		</div>
		<p>
			A large number of the decisions about the design of Box2D
			were based on the need for quick and efficient use of
			memory. In this section I will discuss how and why Box2D
			allocates memory.
		</p>
		<p>
			Box2D tends to allocate a large number of small objects
			(around 50-300 bytes). Using the system heap through
			<tt class="literal">malloc</tt>
			or
			<tt class="literal">new</tt>
			for small objects is inefficient and can cause
			fragmentation. Many of these small objects may have a short
			life span, such as contacts, but can persist for several
			time steps. So we need an allocator that can efficiently
			provide heap memory for these objects.
		</p>
		<p>
			Box2D's solution is to use a
			<span class="emphasis">
				<em>small object</em>
			</span>
			allocator (SOA). The SOA keeps a number of growable pools of
			varying sizes. When a request is made for memory, the SOA
			returns a block of memory that best fits the requested size.
			When a block is freed, it is returned to the pool. Both of
			these operations are fast and cause little heap traffic.
		</p>
		<p>
		Since Box2D uses a SOA, you should never 
		<span class="emphasis"><em>new</em></span>
		or <span class="emphasis"><em>malloc</em></span>
		a body, shape, or joint. You do have to allocate a 
		<tt class="classname">b2World</tt>. The <tt class="classname">b2World</tt> 
		class provides factories for you to create bodies, shapes, and 
		joints. This allows Box2D to use the SOA and hide the gory details
		from you. Never, ever, call <tt class="literal">delete</tt> or 
		<tt class="literal">free</tt> on a body, shape, or joint.
		</p>
		<p>
			While executing a time step, Box2D needs some temporary
			workspace memory. For this, it uses a stack allocator to
			avoid per-step heap allocations. You don't need to interact
			with the stack allocator, but it's good to know it's there.
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e348"></a>
						3.2. Factories and Definitions
					</h2>
				</div>
			</div>
		</div>
		<p>
			As mentioned above, memory management plays a central role
			in the design of the Box2D API. So when you create a
			<tt class="classname">b2Body</tt>
			or a
			<tt class="classname">b2Joint</tt>
			, you need to call the factory methods on
			<tt class="classname">b2World</tt>
			.
		</p>
		<p>There are creation methods:</p>
		<pre class="programlisting">
Method CreateBody:b2Body(def:b2BodyDef)
Method CreateJoint:b2Joint(def:b2JointDef)
		</pre>
		<p>And there are corresponding destruction methods:</p>
		<pre class="programlisting">
Method DestroyBody(body:b2Body)
Method DestroyJoint(joint:b2Joint)
		</pre>
		<p>
			When you create a body or joint, you need to provide a
			<span class="emphasis">
				<em>definition</em>
			</span>
			or
			<span class="emphasis">
				<em>def</em>
			</span>
			for short. These definitions contain all the information
			needed to build the body or joint. By using this approach we
			can prevent construction errors, keep the number of function
			parameters small, provide sensible defaults, and reduce the
			number of accessors.
		</p>
		<p>
			Since shapes musted be parented to a body, they are created
			and destroyed using a factory method on
			<tt class="classname">b2Body</tt>
			:
		</p>
		<pre class="programlisting">
Method CreateShape:b2Shape(def:b2ShapeDef)
Method DestroyShape(shape:b2Shape)
		</pre>
		<p>
			Factories do not retain references to the definitions. So
			you can create and re-use definitions and keep them in
			temporary resources.
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="units"></a>
						3.3. Units
					</h2>
				</div>
			</div>
		</div>
		<p>
			Box2D works with floating point numbers, so some tolerances
			have to be used to make Box2D perform well. These tolerance
			have been tuned to work well with meters-kilogram-second
			(MKS) units. In particular, Box2D has been tuned to work
			well with moving objects between 0.1 and 10 meters. So this
			means objects between soup cans and buses in size should
			work well.
		</p>
		<p>
			Being a 2D physics engine it is tempting to use pixels as
			your units. Unfortunately this will lead to a poor
			simulation and possibly weird behavior. An object of length
			200 pixels would be seen by Box2D as the size of a 45 story
			building. Imagine trying to simulate the movement of a
			high-rise building with an engine that is tuned to simulate
			ragdolls and barrels. It isn't pretty.
		</p>
		<div class="caution"
			style="margin-left: 0.5in; margin-right: 0.5in;">
			<h3 class="title">Caution</h3>
			<p>
				Box2D is tuned for MKS units. Keep the size of moving
				objects roughly between 0.1 and 10 meters. You'll need
				to use some scaling system when you render your
				environment and actors.
			</p>
		</div>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e397"></a>
						3.4. User Data
					</h2>
				</div>
			</div>
		</div>
		<p>
			The
			<tt class="classname">b2Shape</tt>
			,
			<tt class="classname">b2Body</tt>
			, and
			<tt class="classname">b2Joint</tt>
			classes allow you to attach user data as a
			<tt class="literal">void</tt>
			pointer. This is handy when you are examining Box2D data
			structures and you want to determine how they relate to the
			data structures in your game engine.
		</p>
		<p>
			For example, it is typical to attach an
			<span class="emphasis">
				<em>actor</em>
			</span>
			pointer to the rigid body on that actor. This sets up a
			circular reference. If you have the actor, you can get the
			body. If you have the body, you can get the actor.
		</p>
		<pre class="programlisting">
Local actor:GameActor = GameCreateActor()
Local bodyDef:b2BodyDef = new b2BodyDef
bodyDef.SetUserData(actor)
actor.body = box2Dworld.CreateBody(bodyDef)
		</pre>
		<p>
			Here are some examples of cases where you would need the
			user data:
		</p>
		<div class="itemizedlist">
			<ul type="disc">
				<li>
					<p>
						Applying damage to an actor using a collision
						result.
					</p>
				</li>
				<li>
					<p>
						Playing a scripted event if the player is inside
						an axis-aligned box.
					</p>
				</li>
				<li>
					<p>
						Accessing a game structure when Box2D notifies
						you that a joint is going to be destroyed.
					</p>
				</li>
			</ul>
		</div>
		<p>
			Keep in mind that user data is optional and you can put
			anything in it. However, you should be consistent. For
			example, if you want to store an actor pointer on one body,
			you should keep an actor pointer on all bodies. Don't store
			an actor pointer on one body, and a foo pointer on another
			body. This will likely lead to a crash if you try to cast an
			actor pointer into a foo pointer.
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e451"></a>
						3.5. Strawman
					</h2>
				</div>
			</div>
		</div>
		<p>
			If you don't like this API design, that's ok! You have the
			source code! Seriously, if you have feedback about anything
			related to Box2D, please leave a comment in the
			<a href="http://www.box2d.org/forum" target="_top">forum</a>
			.
		</p>
	</div>
</div>
<div class="chapter" lang="en">
	<div class="titlepage">
		<div>
			<div>
				<h2 class="title">
					<a name="d0e459"></a>
					Chapter 4. The World
				</h2>
			</div>
		</div>
	</div>
	<div class="toc">
		<p>
			<b>Table of Contents</b>
		</p>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e462">4.1. About</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e473">
						4.2. Creating and Destroying a World
					</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e496">4.3. Using a World</a>
				</span>
			</dt>
			<dd>
				<dl>
					<dt>
						<span class="sect2">
							<a href="#d0e504">4.3.1. Simulation</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e517">
								4.3.2. Exploring the World
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e544">4.3.3. AABB Queries</a>
						</span>
					</dt>
				</dl>
			</dd>
		</dl>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e462"></a>
						4.1. About
					</h2>
				</div>
			</div>
		</div>
		<p>
			The
			<tt class="classname">b2World</tt>
			class contains the bodies and joints. It manages all aspects
			of the simulation and allows for asynchronous queries (like
			AABB queries). Much of your interactions with Box2D will be
			with a
			<tt class="classname">b2World</tt>
			object.
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e473"></a>
						4.2. Creating and Destroying a World
					</h2>
				</div>
			</div>
		</div>
		<p>
			Creating a world is fairly simple. You need to provide a
			bounding box and a gravity vector.
		</p>
		<p>
			The axis-aligned bounding box should encapsulate the world.
			You can improve performance by making the bounding box a bit
			bigger than your world, say 2x just to be safe. If you have
			lots of bodies that fall into the abyss, your should detect
			this and remove the bodies. This will improve performance
			and prevent floating point overflow.
		</p>
		<p>
			To create and destory a world you need to use
			<tt class="literal">Create</tt>
			and
			<tt class="literal">Free</tt>
			.
		</p>
		<pre class="programlisting">
Local myWorld:b2World = new b2World.Create(aabb, gravity, doSleep);
... do stuff ...
myWorld.Free()
		</pre>
		<div class="caution"
			style="margin-left: 0.5in; margin-right: 0.5in;">
			<h3 class="title">Caution</h3>
			<p>
				Recall that the
				<span class="emphasis">
					<em>world AABB</em>
				</span>
				should always be bigger then the region where your
				bodies are located. If bodies leave the world AABB, then
				they will be frozen. This is not a bug.
			</p>
		</div>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e496"></a>
						4.3. Using a World
					</h2>
				</div>
			</div>
		</div>
		<p>
			The world class contains factories for creating and
			destroying bodies and joints. These factories are discussed
			later in the sections on bodies and joints. There are some
			other interactions with
			<tt class="classname">b2World</tt>
			that I will cover now.
		</p>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e504"></a>
							4.3.1. Simulation
						</h3>
					</div>
				</div>
			</div>
			<p>
				The world class is used to drive the simulation. You
				specify a time step and an iteration count. For example:
			</p>
			<pre class="programlisting">
Local timeStep:Float = 1.0 / 60.0
Local iterationCount:Int = 10
myWorld.DoStep(timeStep, iterationCount)
			</pre>
			<p>
				After the time step you can examine your bodies and
				joints for information. Most likely you will grab the
				position off the bodies so that you can update your
				actors and render them. You can perform the time step
				anywhere in your game loop, but you should be aware of
				the order of things. For example, you must create bodies
				before the time step if you want to get collision
				results for the new bodies in that frame.
			</p>
			<p>
				As I discussed above in the HelloWorld tutorial, you
				should use a fixed time step. By using a larger time
				step you can improve performance in low frame rate
				scenarios. But generally you should use a time step no
				larger than 1/30 seconds. A time step of 1/60 seconds
				will usually deliver a high quality simulation.
			</p>
			<p>
				The iteration count controls how many times the
				constraint solver sweeps over all the contacts and
				joints in the world. More iterations always yields a
				better simulation. But don't trade a small time step for
				a large iteration count. 60Hz and 10 iterations is far
				better than 30Hz and 20 iterations.
			</p>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e517"></a>
							4.3.2. Exploring the World
						</h3>
					</div>
				</div>
			</div>
			<p>
				As mentioned before, the world is a container for bodies
				and joints. You can grab the body and joint lists off
				the world and iterate over them. For example, this code
				wakes up all the bodies in the world:
			</p>
			<pre class="programlisting">
Local b:b2Body = myWorld.GetBodyList()
While b
	b.WakeUp()
	b = b.GetNext()
Wend
			</pre>
			<p>
				Unfortunately life can be more complicated. For example,
				the following code is broken:
			</p>
			<pre class="programlisting">
Local b:b2Body = myWorld.GetBodyList()
While b
	Local myActor:GameActor = GameActor(b.GetUserData())
	If myActor.IsDead() Then
		myWorld.DestroyBody(b) ' ERROR: now GetNext returns garbage.
	End If
	b = b.GetNext()
Wend
			</pre>
			<p>
				Everything goes ok until a body is destroyed. Once a
				body is destroyed, its next pointer becomes invalid. So
				the call to
				<tt class="methodname">b2Body::GetNext()</tt>
				will return garbage. The solution to this is to copy the
				next pointer before destroying the body.
			</p>
			<pre class="programlisting">
Local node:b2Body = myWorld.GetBodyList()
While (node)
	Local b:b2Body = node
	node = node.GetNext()
<p>
	Local myActor:GameActor = GameActor(b.GetUserData())
	If myActor.IsDead() Then
		myWorld.DestroyBody(b)
	End If
Wend
			</pre>
			<p>
				This safely destroys the current body. However, you may
				want to call a game function that may destroy multiple
				bodies. In this case you need to be very careful. The
				solution is application specific, but for convenience
				I'll show one method of solving the problem.
			</p>
			<pre class="programlisting">
Local node:b2Body = myWorld.GetBodyList()
While node
	Local b:b2Body = node
	node = node.GetNext()
<p>
	Local myActor:GameActor = GameActor(b.GetUserData())
	If myActor.IsDead() Then
		Local otherBodiesDestroyed:Int = GameCrazyBodyDestroyer(b)
		If otherBodiesDestroyed Then
			node = myWorld.GetBodyList()
		End If
	End If
Wend
			</pre>
			<p>
				Obviously to make this work,
				<tt class="function">GameCrazyBodyDestroyer</tt>
				must be honest about what it has destroyed.
			</p>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e544"></a>
							4.3.3. AABB Queries
						</h3>
					</div>
				</div>
			</div>
			<p>
				Sometimes you want to determine all the shapes in a
				region. The
				<tt class="classname">b2World</tt>
				class has a fast log(N) method for this using the
				<span class="emphasis">
					<em>broad-phase</em>
				</span>
				data structure. You provide an AABB in world coordinates
				and
				<tt class="classname">b2World</tt>
				returns an array of all the shapes that potentially
				intersect the AABB. This is not exact because what the
				function actually does is return all the shapes whose
				AABBs intersect the specified AABB. For example, the
				following code finds all the shapes that potentially
				intersect a specified AABB and wakes up all of the
				associated bodies.
			</p>
			<pre class="programlisting">
Local aabb:b2AABB = new b2AABB
aabb.SetLowerBound(-1.0, -1.0)
aabb.SetUpperBound(1.0, 1.0)
Local k_bufferSize:Int = 10
Local buffer:b2Shape[] = New b2Shape[k_bufferSize]
Local count:Int = myWorld.Query(aabb, buffer)
For Local i:Int = 0 Until count
	buffer[i].GetBody().WakeUp()
Next
			</pre>
		</div>
	</div>
</div>
<div class="chapter" lang="en">
	<div class="titlepage">
		<div>
			<div>
				<h2 class="title">
					<a name="d0e560"></a>
					Chapter 5. Bodies
				</h2>
			</div>
		</div>
	</div>
	<div class="toc">
		<p>
			<b>Table of Contents</b>
		</p>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e563">5.1. About</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e575">5.2. Body Definition</a>
				</span>
			</dt>
			<dd>
				<dl>
					<dt>
						<span class="sect2">
							<a href="#d0e587">5.2.1. Mass Properties</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e612">
								5.2.2. Position and Angle
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e635">5.2.3. Damping</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e649">
								5.2.4. Sleep Parameters
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#bullets">5.2.5. Bullets</a>
						</span>
					</dt>
				</dl>
			</dd>
			<dt>
				<span class="sect1">
					<a href="#d0e683">5.3. Body Factory</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e720">5.4. Using a Body</a>
				</span>
			</dt>
			<dd>
				<dl>
					<dt>
						<span class="sect2">
							<a href="#d0e725">5.4.1. Mass Data</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e740">
								5.4.2. State Information
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e753">
								5.4.3. Position and Velocity
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e768">
								5.4.4. Forces and Impulses
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e779">
								5.4.5. Coordinate Transformations
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e786">5.4.6. Lists</a>
						</span>
					</dt>
				</dl>
			</dd>
		</dl>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e563"></a>
						5.1. About
					</h2>
				</div>
			</div>
		</div>
		<p>
			Bodies have position and velocity. You can apply forces,
			torques, and impulses to bodies. Bodies can be static or
			dynamic. Static bodies never move and don't collide with
			other static bodies.
		</p>
		<p>
			Bodies are the backbone for shapes. Bodies carry shapes and
			move them around in the world. Bodies are always
			<span class="emphasis">
				<em>rigid bodies</em>
			</span>
			in Box2D. That means that two shapes attached to the same
			rigid body never move relative to each other.
		</p>
		<p>
			You usually keep references to all the bodies you create. This
			way you can query the body positions to update the positions
			of your graphical entities. You should also keep body
			references so you can destroy them when you are done with
			them.
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e575"></a>
						5.2. Body Definition
					</h2>
				</div>
			</div>
		</div>
		<p>
			Before a body is created you must create a body definition (
			<tt class="classname">b2BodyDef</tt>
			). You can create a body definition on the stack or build it
			into your game's data structures. The choice is up to you.
		</p>
		<p>
			Box2D copies the data out of the body definition, it does
			not keep a pointer to the body definition. This means you
			can recycle a body definition to create multiple bodies.
		</p>
		<p>
			Lets go over some of the key members of the body definition.
		</p>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e587"></a>
							5.2.1. Mass Properties
						</h3>
					</div>
				</div>
			</div>
			<p>
				There are a few ways to establish the mass properties
				for a body.
			</p>
			<div class="orderedlist">
				<ol type="1">
					<li>
						<p>
							Set the mass properties explicitly in the
							body definition.
						</p>
					</li>
					<li>
						<p>
							Set the mass properties explicitly on the
							body (after it has been created).
						</p>
					</li>
					<li>
						<p>
							Set the mass properties based on the density
							of the attaced shapes.
						</p>
					</li>
				</ol>
			</div>
			<p>
				In many game scenarios it makes sense to compute mass
				based on shape densities. This helps to ensure that
				bodies have reasonable and consistent mass values.
			</p>
			<p>
				However, other game scenarios may require specific mass
				values. For example, you may have a mechanism, like a
				scale that needs precises mass values.
			</p>
			<p>
				You can explicitly set the mass properties in the body
				definition as follows:
			</p>
			<pre class="programlisting">
bodyDef.GetMassData().SetMass(2.0) ' the body's mass in kg
bodyDef.SetCenter(b2Vec2.ZERO)     ' the center of mass in local coordinates
bodyDef.SetRotationalInertia(3.0)  ' the rotational inertia in kg*m^2.
			</pre>
			<p>
				The other methods of setting the mass properties are
				covered elsewhere in this document.
			</p>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e612"></a>
							5.2.2. Position and Angle
						</h3>
					</div>
				</div>
			</div>
			<p>
				The body definition gives you the chance to initialize
				the position of the body on creation. This has better
				performance than creating the body at the world origin
				and then moving the body.
			</p>
			<p>
				A body has two main points of interest. The first point
				is the body's
				<span class="emphasis">
					<em>origin</em>
				</span>
				. Shapes and joints are attached relative to the body's
				origin. The second point of interest is the
				<span class="emphasis">
					<em>center of mass</em>
				</span>
				. The center of mass is determined from mass
				distribution of the attached shapes or is explicitly set
				with
				<tt class="classname">b2MassData</tt>
				. Much of Box2D's internal computations use the center
				of mass position. For example
				<tt class="classname">b2Body</tt>
				stores the linear velocity for the center of mass.
			</p>
			<p>
				When you are building the body definition, you may not
				know where the center of mass is located. Therefore you
				specify the position of the body's origin. You may also
				specify the body's angle in radians, which is not
				affected by the position of the center of mass. If you
				later change the mass properties of the body, then the
				center of mass may move on the body, but the origin
				position does not change and the attached shapes and
				joints do not move.
			</p>
			<pre class="programlisting">
bodyDef.SetPositionXY(0.0, 2.0) ' the body's origin position
bodyDef.SetAngle(45)            ' the body's angle in degrees.
			</pre>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e635"></a>
							5.2.3. Damping
						</h3>
					</div>
				</div>
			</div>
			<p>
				Damping is used to reduce the world velocity of bodies.
				Damping is different than friction because friction only
				occurs with contact and damping is much cheaper to
				simulate than friction. However, damping is not a
				replacement for friction and the two effects should be
				used together.
			</p>
			<p>
				Damping parameters should be between 0 and infinity,
				with 0 meaning no damping, and infinity meaning full
				damping. Normally you will use a damping value between 0
				and 0.1. I generally do not use linear damping because
				it makes bodies look
				<span class="emphasis">
					<em>floaty</em>
				</span>
				.
			</p>
			<pre class="programlisting">
bodyDef.SetLinearDamping(0.0)
bodyDef.SetAngularDamping(0.01)
			</pre>
			<p>
				Damping is approximated for stability and performance.
				At small damping values the damping effect is mostly
				independent of the time step. At larger damping values,
				the damping effect will vary with the time step. This is
				not an issue if you use a fixed time step (recommended).
			</p>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e649"></a>
							5.2.4. Sleep Parameters
						</h3>
					</div>
				</div>
			</div>
			<p>
				What does sleep mean? Well it is expensive to simulate
				bodies, so the less we have to simulate the better. When
				a body comes to rest we would like to stop simulating
				it.
			</p>
			<p>
				When Box2D determines that a body (or group of bodies)
				has come to rest, the body enters a sleep state which
				has very little CPU overhead. If an awake body collides
				with a sleeping body, then the sleeping body wakes up.
				Bodies will also wake up if a joint or contact attached
				to them is destroyed. You can also wake a body manually.
			</p>
			<p>
				The body definition lets you specify whether a body can
				<span class="emphasis">
					<em>sleep</em>
				</span>
				and whether a body is created sleeping.
			</p>
			<pre class="programlisting">
bodyDef.SetAllowSleep(True)
bodyDef.SetIsSleeping(False)
			</pre>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="bullets"></a>
							5.2.5. Bullets
						</h3>
					</div>
				</div>
			</div>
			<p>
				Game simulation usually generates a sequence of images
				that are played at some frame rate. In this setting
				rigid bodies can move by a large amount in one time
				step. If a physics engine doesn't account for the large
				motion, you may see some objects incorrectly pass
				through each other. This effect is called
				<span class="emphasis">
					<em>tunneling</em>
				</span>
				.
			</p>
			<p>
				By default, Box2D uses continuous collision detection
				(CCD) to prevent dynamic bodies from tunneling through
				static bodies. This is done by sweeping shapes from
				their old position to their new positions. The engine
				looks for new collisions during the sweep and computes
				the time of impact (TOI) for these collisions. Bodies
				are moved to their first TOI and then simulated to the
				end of the original time step. This process is repeated
				as necessary.
			</p>
			<p>
				Normally CCD is not used between dynamic bodies. This is
				done to keep performance reasonable. In some game
				scenarios you need dynamic bodies to use CCD. For
				example, you may want to shoot a high speed bullet at a
				thin wall. Without CCD, the bullet my tunnel through the
				wall.
			</p>
			<p>
				Fast moving objects in Box2D are called bullets. You
				should decide what bodies should be bullets based on
				your game design. If you decide a body should be treated
				as a bullet, use the following setting.
			</p>
			<pre class="programlisting">
bodyDef.SetIsBullet(True)
</pre>
			<p>The bullet flag only affects dynamic bodies.</p>
			<p>
				CCD is expensive so you probably don't want all moving
				bodies to be bullets. So by default Box2D only uses CCD
				between moving bodies and static bodies. This is an
				effective approach to prevent bodies from escaping your
				game world. However, you may have some fast moving
				bodies that that require CCD all the time.
			</p>
		</div>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e683"></a>
						5.3. Body Factory
					</h2>
				</div>
			</div>
		</div>
		<p>
			Bodies are created and destroyed using a body factory
			provided by the world class. This lets the world create the
			body with an efficient allocator and add the body to the
			world data structure.
		</p>
		<p>
			Bodies can be dynamic or static depending on the mass
			properties. Both body types use the same creation and
			destruction methods.
		</p>
		<pre class="programlisting">
Local dynamicBody:b2Body = myWorld.CreateBody(bodyDef)
... do stuff ... 
myWorld.DestroyBody(dynamicBody)
dynamicBody = NULL
		</pre>
		<p>
			Static bodies do not move under the influence of other
			bodies. You may manually move static bodies, but you should
			be careful so that you don't squash dynamic bodies between
			two or more static bodies. Friction will not work correctly
			if you move a static body. Static bodies never simulate on
			their own and they never collide with other static bodies.
			It is faster to attach several shapes to a static body than
			to create several static bodies with a single shape on each
			one. Interally, Box2D sets the mass and inverse mass of
			static bodies to zero. This makes the math work out so that
			most algorithms don't need to treat static bodies as a
			special case.
		</p>
		<p>
			Box2D does not keep a reference to the body definition or
			any of the data it holds (except user data references). So you
			can create temporary body definitions and reuse the same
			body definitions.
		</p>
		<p>
			Box2D allows you to avoid destroying bodies by deleting your
			<tt class="classname">b2World</tt>
			object, which does all the cleanup work for you. However,
			you should be mindful to nullify any body references that you
			keep in your game engine.
		</p>
		<p>
			When you destroy a body, the attached shapes and joints are
			automatically destroyed. This has important implications for
			how you manage shape and joint references. See
			<a href="#implicit_destruction"
				title="9.2. Implicit Destruction">
				Section 9.2, <pre></pre>#8220;Implicit Destruction&#8221;
			</a>
			for details.
		</p>
		<p>
			Suppose you want to connect a dynamic body to ground with a
			joint. You'll need to connect the joint to a static body. If
			you don't have a static body, you can get a shared ground
			body from your world object. You can also attach static
			shapes to the ground body.
		</p>
		<pre class="programlisting">
Local ground:b2Body = myWorld.GetGroundBody()
... build a joint using the ground body ...
		</pre>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e720"></a>
						5.4. Using a Body
					</h2>
				</div>
			</div>
		</div>
		<p>
			After creating a body, there are many operations you can
			perform on the body. These include setting mass properties,
			accessing position and velocity, applying forces, and
			transforming points and vectors.
		</p>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e725"></a>
							5.4.1. Mass Data
						</h3>
					</div>
				</div>
			</div>
			<p>
				You can adjust the mass of a body at run-time. This is
				usually done when you create or destroy shapes on a
				body. You may want to adjust the mass of the body based
				on the current shapes.
			</p>
			<pre class="programlisting">
Method SetMassFromShapes()
</pre>
			<p>
				You may also want to set the mass properties directly.
				For example, you may change the shapes, but want to use
				your own mass formulas.
			</p>
			<pre class="programlisting">
Method SetMass(massData:b2MassData)
			</pre>
			<p>
				The body's mass data is available through the following
				functions:
			</p>
			<pre class="programlisting">
Method GetMass:Float()
Method GetInertia:Float()
Method GetLocalCenter:b2Vec2()
			</pre>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e740"></a>
							5.4.2. State Information
						</h3>
					</div>
				</div>
			</div>
			<p>
				There are many aspects to the body's state. You can
				access this state data efficient through the following
				functions:
			</p>
			<pre class="programlisting">
Method IsBullet:Int()
Method SetBullet(flag:Int)
<p>
Method IsStatic:Int()
Method IsDynamic:Int()
<p>
Method IsFrozen:Int()
<p>
Method IsSleeping:Int()
Method AllowSleeping(flag:Int)
Method WakeUp()
			</pre>
			<p>
				The bullet state is described in
				<a href="#bullets" title="5.2.5. Bullets">
					Section 5.2.5, <pre></pre>#8220;Bullets&#8221;
				</a>
				. The frozen state is described in
				<a href="#world_boundary"
					title="9.1. World Boundary">
					Section 9.1, <pre></pre>#8220;World Boundary&#8221;
				</a>
				.
			</p>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e753"></a>
							5.4.3. Position and Velocity
						</h3>
					</div>
				</div>
			</div>
			<p>
				You access the position and rotation of a body. This is
				common when rendering your associated game actor. You
				can also set the position, although this is less common
				since you will normally use Box2D to simulate movement.
			</p>
			<pre class="programlisting">
Method SetXForm:Int(position:b2Vec2, angle:Float)
Method GetXForm:b2XForm()
Method GetPosition:b2Vec2()
Method GetAngle:Float()
			</pre>
			<p>
				You can access the center of mass position in world
				coordinates. Much of the internal simulation in Box2D
				uses the center of mass. However, you should normally
				not need to access it. Instead you will usually work
				with the body transform.
			</p>
			<pre class="programlisting">
Method GetWorldCenter:b2Vec2()
			</pre>
			<p>
				You can access the linear and angular velocity. The
				linear velocity is for the center of mass.
			</p>
			<pre class="programlisting">
Method SetLinearVelocity(v:b2Vec2)
Method GetLinearVelocity:b2Vec2()
Method SetAngularVelocity(omega:Float)
Method GetAngularVelocity:Float()
			</pre>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e768"></a>
							5.4.4. Forces and Impulses
						</h3>
					</div>
				</div>
			</div>
			<p>
				You can apply forces, torques, and impulses to a body.
				When you apply a force or an impulse, you provide a
				world point where the load is applied. This often
				results in a torque about the center of mass.
			</p>
			<pre class="programlisting">
Method ApplyForce(force:b2Vec2, point:b2Vec2)
Method ApplyTorque(float32 torque:Float)
Method ApplyImpulse(impulse:b2Vec2, point:b2Vec2)
			</pre>
			<p>
				Applying a force, torque, or impulse wakes the body.
				Sometimes this is undesirable. For example, you may be
				applying a steady force and want to allow the body to
				sleep to improve performance. In this case you can use
				the following code.
			</p>
			<pre class="programlisting">
If Not myBody.IsSleeping() Then
	myBody.ApplyForce(myForce, myPoint)
End If
			</pre>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e779"></a>
							5.4.5. Coordinate Transformations
						</h3>
					</div>
				</div>
			</div>
			<p>
				The body class has some utility functions to help you
				transform points and vectors between local and world
				space. If you don't understand these concepts, please
				read "Essential Mathematics for Games and Interactive
				Applications" by Jim Van Verth and Lars Bishop. These
				functions are efficient, so use them with impunity.
			</p>
			<pre class="programlisting">
Method GetWorldPoint:b2Vec2(localPoint:b2Vec2)
Method GetWorldVector:b2Vec2(localVector:b2Vec2)
Method GetLocalPoint:b2Vec2(worldPoint:b2Vec2)
Method GetLocalVector:b2Vec2(worldVector:b2Vec2)
			</pre>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e786"></a>
							5.4.6. Lists
						</h3>
					</div>
				</div>
			</div>
			<p>
				You can iterate over a body's shapes. This is mainly
				useful if you need to access the shape's user data.
			</p>
			<pre class="programlisting">
Local s:b2Shape = body.GetShapeList()
While s
	Local data:MyShapeData = MyShapeData(s.GetUserData())
	... do something with data ...
	s = s.GetNext()
Wend
			</pre>
			<p>You can similarly iterate over the body's joint list.</p>
		</div>
	</div>
</div>
<div class="chapter" lang="en">
	<div class="titlepage">
		<div>
			<div>
				<h2 class="title">
					<a name="shapes"></a>
					Chapter 6. Shapes
				</h2>
			</div>
		</div>
	</div>
	<div class="toc">
		<p>
			<b>Table of Contents</b>
		</p>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e798">6.1. About</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e807">6.2. The Shape Definition</a>
				</span>
			</dt>
			<dd>
				<dl>
					<dt>
						<span class="sect2">
							<a href="#d0e815">
								6.2.1. Friction and Restitution
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e837">6.2.2. Density</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e845">6.2.3. Filtering</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e889">6.2.4. Sensors</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e898">
								6.2.5. Circle Definitions
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e910">
								6.2.6. Polygon Definitions
							</a>
						</span>
					</dt>
				</dl>
			</dd>
			<dt>
				<span class="sect1">
					<a href="#d0e950">6.3. Shape Factory</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e976">6.4. Using a Shape</a>
				</span>
			</dt>
		</dl>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e798"></a>
						6.1. About
					</h2>
				</div>
			</div>
		</div>
		<p>
			Shapes are the collision geometry attached to bodies. Shapes
			are also used to define the mass of a body. This lets you
			specify the density and let Box2D do the work of computing
			the mass properties.
		</p>
		<p>
			Shapes have properties of friction and restitution. Shapes
			carry collision filtering information to let you prevent
			collisions between certain game objects.
		</p>
		<p>
			Shapes are always owned by a body. You can attach multiple
			shapes to a single body. Shapes are abstract classes so that
			many types of shapes can be implemented in Box2D. If you are
			brave, you can implement your own shape type (and collision
			algorithms).
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e807"></a>
						6.2. The Shape Definition
					</h2>
				</div>
			</div>
		</div>
		<p>
			Shape definitions are used to create shapes. There is common
			shape data held by
			<tt class="classname">b2ShapeDef</tt>
			and specific shape data held by derived classes.
		</p>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e815"></a>
							6.2.1. Friction and Restitution
						</h3>
					</div>
				</div>
			</div>
			<p>
				Friction is used to make objects slide along each other
				realistically. Box2D supports static and dynamic
				friction, but uses the same parameter for both. Friction
				is simulated accurately in Box2D and the friction
				strength is proportional to the normal force (this is
				called
				<span class="emphasis">
					<em>Coulomb friction</em>
				</span>
				). The friction parameter is usually set between 0 and
				1. A value of zero turns off friction and a value of one
				makes the friction strong. When the friction is computed
				between two shapes, Box2D must combine the friction
				parameters of the two shapes. This is done with the
				following formula:
			</p>
			<pre class="programlisting">
Local friction:Float = Sqr(shape1.GetFriction() * shape2.GetFriction())
			</pre>
			<p>
				Restitution is used to make objects bounce. The
				restitution value is usually set to be between 0 and 1.
				Consider dropping a ball on a table. A value of zero
				means the ball won't bounce. This is called an
				<span class="emphasis">
					<em>inelastic</em>
				</span>
				collision. A value of one means the ball's velocity will
				be exactly reflected. This is called a
				<span class="emphasis">
					<em>perfectly elastic</em>
				</span>
				collision. Restitution is combined using the following
				formula.
			</p>
			<pre class="programlisting">
Local restitution:Float = b2Max(shape1.GetRestitution(), shape2.GetRestitution())
			</pre>
			<p>
				When a shape develops multiple contacts, restitution is
				simulated approximately. This is because Box2D uses an
				iterative solver. Box2D also uses inelastic collisions
				when the collision velocity is small. This is done to
				prevent jitter.
			</p>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e837"></a>
							6.2.2. Density
						</h3>
					</div>
				</div>
			</div>
			<p>
				Box2D optionally computes the mass and rotational
				inertia of bodies using the mass distribution implied by
				the attached shapes. Specifying mass directly can often
				lead to poorly tuned simulations. Therefore, the
				recommended way of specifying body mass is by setting
				the shape densities and calling
				<tt class="literal">b2Body::SetMassFromShape</tt>
				once all the shapes are attached to the body.
			</p>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e845"></a>
							6.2.3. Filtering
						</h3>
					</div>
				</div>
			</div>
			<p>
				Collision filtering is a system for preventing collision
				between shapes. For example, say you make a character
				that rides a bicycle. You want the bicycle to collide
				with the terrain and the character to collide with the
				terrain, but you don't want the character to collide
				with the bicycle (because they must overlap). Box2D
				supports such collision filtering using categories and
				groups.
			</p>
			<p>
				Box2D supports 16 collision categories. For each shape
				you can specify which category it belongs to. You also
				specify what other categories this shape can collide
				with. For example, you could specify in a multiplayer
				game that all players don't collide with each other and
				monsters don't collide with each other, but players and
				monsters should collide. This is done with
				<span class="emphasis">
					<em>masking bits</em>
				</span>
				. For example:
			</p>
			<pre class="programlisting">
playerShapeDef.GetFilter().SetCategoryBits($0002)
monsterShapeDef.GetFilter().SetCategoryBits($0004)
playerShape.GetFilter().SetMaskBits($0004)
monsterShapeDef.GetFilter().SetMaskBits($0002)
			</pre>
			<p>
				Collision groups let you specify an integral group
				index. You can have all shapes with the same group index
				always collide (positive index) or never collide
				(negative index). Group indices are usually used for
				things that are somehow related, like the parts of a
				bicycle. In the following example, shape1 and shape2
				always collide, but shape3 and shape4 never collide.
			</p>
			<pre class="programlisting">
shape1Def.GetFilter().SetGroupIndex(2)
shape2Def.GetFilter().SetGroupIndex(2)
shape3Def.GetFilter().SetGroupIndex(-8)
shape4Def.GetFilter().SetGroupIndex(-8)
			</pre>
			<p>
				Collisions between shapes of different group indices are
				filtered according the category and mask bits. In other
				words, group filtering has higher precendence than
				category filtering.
			</p>
			<p>
				Note that additional collision filtering occurs in
				Box2D. Here is a list:
			</p>
			<div class="itemizedlist">
				<ul type="disc">
					<li>
						<p>
							A shape on a static body never collides with
							a shape on another static body.
						</p>
					</li>
					<li>
						<p>
							Shapes on the same body never collide with
							each other.
						</p>
					</li>
					<li>
						<p>
							You can optionally enable/disable collision
							between shapes on bodies connected by a
							joint.
						</p>
					</li>
				</ul>
			</div>
			<p>
				Sometimes you might need to change collision filtering
				after a shape has already been created. You can get and
				set the
				<span class="structname">b2FilterData</span>
				structure on an existing shape using
				<tt class="function">b2Shape::GetFilterData</tt>
				and
				<tt class="function">b2Shape::SetFilterData</tt>
				. Box2D caches filtering results, so you must manually
				re-filter a shape using
				<tt class="function">b2World::Refilter</tt>
				.
			</p>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e889"></a>
							6.2.4. Sensors
						</h3>
					</div>
				</div>
			</div>
			<p>
				Some times game logic needs to know when two shapes
				overlap yet there should be no collision response. This
				is done by using sensors. A sensor is a shape that
				detects collision but does not produce a response.
			</p>
			<p>
				You can flag any shape as being a sensor. Sensors may be
				static or dynamic. Remember that you may have multiple
				shapes per body and you can have any mix of sensors and
				solid shapes.
			</p>
			<pre class="programlisting">
myShapeDef.SetIsSensor(True)
			</pre>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e898"></a>
							6.2.5. Circle Definitions
						</h3>
					</div>
				</div>
			</div>
			<p>
				<tt class="classname">b2CircleDef</tt>
				extends
				<tt class="classname">b2ShapeDef</tt>
				and adds a radius and a local position.
			</p>
			<pre class="programlisting">
Local def:b2CircleDef = New b2CircleDef
def.SetRadius(1.5)
def.SetLocalPosition(Vec2(1.0, 0.0))
			</pre>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e910"></a>
							6.2.6. Polygon Definitions
						</h3>
					</div>
				</div>
			</div>
			<p>
				<tt class="classname">b2PolyDef</tt>
				is used to implement convex polygons. They are a bit
				tricky to use correctly, so please read closely. The
				maximum vertex count is defined by
				<tt class="literal">b2_maxPolyVertices</tt>
				which is currently 8. If you need to use more vertices,
				you must modify
				<tt class="literal">b2_maxPolyVertices</tt>
				in
				<tt class="literal">b2Settings.h</tt>
				.
			</p>
			<p>
				When you build a polygon definition you must specify the
				number of vertices you will use. The vertices must be
				specified in
				<span class="emphasis">
					<em>counter-clockwise</em>
				</span>
				(CCW) order about the z-axis of a right-handed
				coordinate system. This might turn out to be clockwise
				on your screen, depending on your coordinate system
				conventions.
			</p>
			<p>
				Polygons must be
				<span class="emphasis">
					<em>convex</em>
				</span>
				. In other words, each vertex must point outwards to
				some degree. Finally, you must not overlap any vertices.
				Box2D will automatically close the loop.
			</p>
			<div class="informalfigure">
				<div class="mediaobject">
					<img src="images/convex_concave.gif"></div>
			</div>
			<p>
				Here is an example of a polygon definition of a
				triangle:
			</p>
			<pre class="programlisting">
Local triangleDef:b2PolygonDef = New b2PolygonDef
Local vertices:b2Vec2[] = New b2Vec2[3]
vertices[0] = Vec2(-1.0, 0.0)
vertices[1] = Vec2(1.0, 0.0)
vertices[2] = Vec2(0.0, 2.0)
triangleDef.SetVertices(vertices)
			</pre>
			<p>
				The vertices are defined in the coordinate system of the
				parent body. If you need to offset a polygon within the
				parent body, then just offset all the vertices.
			</p>
			<p>
				For convenience, there are functions to initialize
				polygons as boxes. You can have either an axis-aligned
				box centered at the body origin or an oriented box
				offset from the body origin.
			</p>
			<pre class="programlisting">
Local alignedBoxDef:b2PolygonDef = New b2PolygonDef
Local hx:Float = 1.0 ' half-width
Local hy:Float = 2.0 ' half-height
alignedBoxDef.SetAsBox(hx, hy)
<p>
Local orientedBoxDef:b2PolygonDef = New b2PolygonDef
Local center:b2Vec2 = Vec2(-1.5, 0.0)
Local angle:Float = 90
orientedBoxDef.SetAsOrientedBox(hx, hy, center, angle)
			</pre>
		</div>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e950"></a>
						6.3. Shape Factory
					</h2>
				</div>
			</div>
		</div>
		<p>
			Shapes are created by initializing a shape definition and
			then passing the definition to the parent body.
		</p>
		<pre class="programlisting">
Local circleDef:b2CircleDef = new b2CircleDef
circleDef.SetRadius(3.0)
circleDef.SetDensity(2.5)
Local myShape:b2Shape = myBody.CreateShape(circleDef)
[optionally store shape reference somewhere]
		</pre>
		<p>
			This creates the shape and attaches it to the body. You do
			not need to store the shape pointer since the shape will
			automatically be destroyed when the parent body is destroyed
			(see
			<a href="#implicit_destruction"
				title="9.2. Implicit Destruction">
				Section 9.2, <pre></pre>#8220;Implicit Destruction&#8221;
			</a>
			).
		</p>
		<p>
			After you finish adding shapes to a body, you may want to
			recompute the mass properties of the body based on the child
			shapes.
		</p>
		<pre class="programlisting">
myBody.SetMassFromShapes()
		</pre>
		<p>
			This function is expensive, so you should only call it when
			necessary.
		</p>
		<p>
			You can destroy a shape on the parent body easily. You may
			do this to model a breakable object. Otherwise you can just
			leave the shape alone and let the body destruction take care
			of destroying the attached shapes.
		</p>
		<pre class="programlisting">
myBody.DestroyShape(myShape)
		</pre>
		<p>
			After removing shapes from a body, you may want to call
			<tt class="literal">SetMassFromShapes</tt>
			again.
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e976"></a>
						6.4. Using a Shape
					</h2>
				</div>
			</div>
		</div>
		<p>
			There's not much to say here. You can get a shape's type and
			its parent body. You can also test a point to see if it is
			contained within the shape. Look at
			<tt class="literal">b2Shape.h</tt>
			for details.
		</p>
	</div>
</div>
<div class="chapter" lang="en">
	<div class="titlepage">
		<div>
			<div>
				<h2 class="title">
					<a name="d0e984"></a>
					Chapter 7. Joints
				</h2>
			</div>
		</div>
	</div>
	<div class="toc">
		<p>
			<b>Table of Contents</b>
		</p>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e987">7.1. About</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e996">7.2. The Joint Definition</a>
				</span>
			</dt>
			<dd>
				<dl>
					<dt>
						<span class="sect2">
							<a href="#d0e1018">7.2.1. Distance Joint</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1034">7.2.2. Revolute Joint</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1077">
								7.2.3. Prismatic Joint
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1097">7.2.4. Pulley Joint</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1123">7.2.5. Gear Joint</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1150">7.2.6. Mouse Joint</a>
						</span>
					</dt>
				</dl>
			</dd>
			<dt>
				<span class="sect1">
					<a href="#d0e1155">7.3. Joint Factory</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e1187">7.4. Using Joints</a>
				</span>
			</dt>
			<dd>
				<dl>
					<dt>
						<span class="sect2">
							<a href="#d0e1200">
								7.4.1. Using Distance Joints
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1205">
								7.4.2. Using Revolute Joints
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1226">
								7.4.3. Using Prismatic Joints
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1233">
								7.4.4. Using Pulley Joints
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1240">
								7.4.5. Using Gear Joints
							</a>
						</span>
					</dt>
					<dt>
						<span class="sect2">
							<a href="#d0e1248">
								7.4.6. Using Mouse Joints
							</a>
						</span>
					</dt>
				</dl>
			</dd>
		</dl>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e987"></a>
						7.1. About
					</h2>
				</div>
			</div>
		</div>
		<p>
			Joints are used to constrain bodies to the world or to each
			other. Typical examples in games include ragdolls, teeters,
			and pulleys. Joints can be combined in many different ways
			to create interesting motions.
		</p>
		<p>
			Some joints provide limits so you can control the range of
			motion. Some joint provide motors which can be used to drive
			the joint at a prescribed speed until a prescribed
			force/torque is exceeded.
		</p>
		<p>
			Joint motors can be used in many ways. You can use motors to
			control position by specifying a joint velocity that is
			proportional to the difference between the actual and
			desired position. You can also use motors to simulate joint
			friction: set the joint velocity to zero and provide a
			small, but significant maximum motor force/torque. Then the
			motor will attempt to keep the joint from moving until the
			load becomes too strong.
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e996"></a>
						7.2. The Joint Definition
					</h2>
				</div>
			</div>
		</div>
		<p>
			Each joint type has a definition that derives from
			<tt class="classname">b2JointDef</tt>
			. All joints are connected between two different bodies. One
			body may static. If you want to waste memory, then create a
			joint between two static bodies. :)
		</p>
		<p>
			You can specify user data for any joint type and you can
			provide a flag to prevent the attached bodies from colliding
			with each other. This is actually the default behavior and
			you must set the
			<tt class="literal">collideConnected</tt>
			Boolean to allow collision between to connected bodies.
		</p>
		<p>
			Many joint definitions require that you provide some
			geometric data. Often a joint will be defined by
			<span class="emphasis">
				<em>anchor points</em>
			</span>
			. These are points fixed in the attached bodies. Box2D
			requires these points to be specified in local coordinates.
			This way the joint can be specified even when the current
			body transforms violate the joint constraint --- a common
			ocurrence when a game is saved and reloaded. Additionally,
			some joint definitions need to know the default relative
			angle between the bodies. This is necessary to constraint
			rotation correctly via joint limits or a fixed relative
			angle.
		</p>
		<p>
			Initializing the geometric data can be tedious, so many
			joints have initialization functions that use the current
			body transforms to remove much of the work. However, these
			initialization functions should usually only be used for
			prototyping. Production code should define the geometry
			directly. This will make joint behavior more robust.
		</p>
		<p>
			The rest of the joint definition data depends on the joint
			type. We cover these now.
		</p>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e1018"></a>
							7.2.1. Distance Joint
						</h3>
					</div>
				</div>
			</div>
			<p>
				One of the simplest joint is a distance joint which says
				that the distance between two points on two bodies must
				be constant. When you specify a distance joint the two
				bodies should already be in place. Then you specify the
				two
				<span class="emphasis">
					<em>anchor</em>
				</span>
				points in world coordinates. The first anchor point is
				connected to body 1, and the second anchor point is
				connected to body 2. These points imply the length of
				the distance constraint.
			</p>
			<div class="informalfigure">
				<div class="mediaobject">
					<img src="images/distanceJoint.gif"></div>
			</div>
			<p>
				Here is an example of a distance joint definition. In
				this case we decide to allow the bodies to collide.
			</p>
			<pre class="programlisting">
Local jointDef:b2DistanceJointDef = New b2DistanceJointDef
jointDef.Initialize(myBody1, myBody2, worldAnchorOnBody1, worldAnchorOnBody2)
jointDef.SetCollideConnected(True)
			</pre>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e1034"></a>
							7.2.2. Revolute Joint
						</h3>
					</div>
				</div>
			</div>
			<p>
				A revolute joint forces two bodies to share a common
				anchor point, often called a
				<span class="emphasis">
					<em>hinge point</em>
				</span>
				. The revolute joint has a single degree of freedom: the
				relative rotation of the two bodies. This is called the
				<span class="emphasis">
					<em>joint angle</em>
				</span>
				.
			</p>
			<div class="informalfigure">
				<div class="mediaobject">
					<img src="images/revoluteJoint.gif"></div>
			</div>
			<p>
				To specify a revolute you need to provide two bodies and
				a single anchor point in world space. The initialization
				function assumes that the bodies are already in the
				correct position.
			</p>
			<p>
				In this example, two bodies are connected by a revolute
				joint at the first body's center of mass.
			</p>
			<pre class="programlisting">
Local jointDef:b2RevoluteJointDef = New b2RevoluteJointDef
jointDef.Initialize(myBody1, myBody2, myBody1.GetWorldCenter())
			</pre>
			<p>
				The revolute joint angle is positive when body2 rotates
				CCW about the angle point. Like all angles in Box2D, the
				revolute angle is measured in radians. By convention the
				revolute joint angle is zero when the joint is created
				using
				<tt class="literal">Initialize()</tt>
				, regardless of the current rotation of the two bodies.
			</p>
			<p>
				In some cases you might wish to control the joint angle.
				For this, the revolute joint can optionally simulate a
				joint limit and/or a motor.
			</p>
			<p>
				A joint limit forces the joint angle to remain between
				an lower and upper bound. The limit will apply as much
				torque as needed to make this happen. The limit range
				should include zero, otherwise the joint will lurch when
				the simulation begins.
			</p>
			<p>
				A joint motor allows you to specify the joint speed (the
				time derivative of the angle). The speed can be negative
				or positive. A motor can have infinite force, but this
				is usually not desirable. Have you ever heard the
				expression:
			</p>
			<div class="caution"
				style="margin-left: 0.5in; margin-right: 0.5in;">
				<h3 class="title">Caution</h3>
				<p>
					"What happens when an irresistible force meets an
					immovable object?"
				</p>
			</div>
			<p>
				I can tell you it's not pretty. So you can provide a
				maximum torque for the joint motor. The joint motor will
				maintain the specified speed unless the required torque
				exceeds the specified maximum. When the maximum torque
				is exceeded, the joint will slow down and can even
				reverse.
			</p>
			<p>
				You can use a joint motor to simulate joint friction.
				Just set the joint speed to zero, and set the maximum
				torque to some small, but significant value. The motor
				will try to prevent the joint from rotating, but will
				yield to a significant load.
			</p>
			<p>
				Here's a revision of the revolute joint definition
				above; this time the joint has a limit and a motor
				enabled. The motor is setup to simulate joint friction.
			</p>
			<pre class="programlisting">
Local jointDef:b2RevoluteJointDef = New b2RevoluteJointDef
jointDef.Initialize(body1, body2, myBody1.GetWorldCenter())
jointDef.SetLowerAngle(-90)
jointDef.SetUpperAngle(45)
jointDef.EnableLimit(True)
jointDef.SetMaxMotorTorque(10.0)
jointDef.SetMotorSpeed(0.0)
jointDef.EnableMotor(True)
			</pre>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e1077"></a>
							7.2.3. Prismatic Joint
						</h3>
					</div>
				</div>
			</div>
			<p>
				A prismatic joint allows for relative translation of two
				bodies along a specified axis. A prismatic joint
				prevents relative rotation. Therefore, a prismatic joint
				has a single degree of freedom.
			</p>
			<div class="informalfigure">
				<div class="mediaobject">
					<img src="images/prismaticJoint.gif"></div>
			</div>
			<p>
				The prismatic joint definition is similar to the
				revolute joint description; just substitute translation
				for angle and force for torque. Using this analogy
				provides an example prismatic joint definition with a
				joint limit and a friction motor:
			</p>
			<pre class="programlisting">
Local jointDef:b2PrismaticJointDef = new b2PrismaticJointDef
Local worldAxis:b2Vec2 = new b2Vec2.Create(1.0, 0.0)
jointDef.Initialize(myBody1, myBody2, myBody1.GetWorldCenter(), worldAxis)
jointDef.SetLowerTranslation(-5.0)
jointDef.SetUpperTranslation(2.5)
jointDef.SetEnableLimit(True)
jointDef.SetMotorForce(1.0)
jointDef.SetMotorSpeed(0.0)
jointDef.EnableMotor(True)
			</pre>
			<p>
				The revolute joint has an implicit axis coming out of
				the screen. The prismatic joint needs an explicit axis
				parallel to the screen. This axis is fixed in the two
				bodies and follows their motion.
			</p>
			<p>
				Like the revolute joint, the prismatic joint translation
				is zero when the joint is created using
				<tt class="literal">Initialize()</tt>
				. So be sure zero is between your lower and upper
				translation limits.
			</p>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e1097"></a>
							7.2.4. Pulley Joint
						</h3>
					</div>
				</div>
			</div>
			<p>
				A pulley is used to create an idealized pulley. The
				pulley connects two bodies to ground and to each other.
				As one body goes up, the other goes down. The total
				length of the pulley rope is conserved according to the
				initial configuration.
			</p>
			<pre class="programlisting">
length1 + length2 = constant
			</pre>
			<div class="informalfigure">
				<div class="mediaobject">
					<img src="images/pulleyJoint.gif"></div>
			</div>
			<p>
				You can supply a ratio that simulates a
				<span class="emphasis">
					<em>block and tackle</em>
				</span>
				. This causes one side of the pulley to extend faster
				than the other. At the same time the constraint force is
				smaller on one side than the other. You can use this to
				create mechanical leverage.
			</p>
			<pre class="programlisting">
length1 + ratio * length2 = constant
			</pre>
			<p>
				For example, if the ratio is 2, then length1 will vary
				at twice the rate of length2. Also the force in the rope
				attached to body1 will have half the constraint force as
				the rope attached to body2.
			</p>
			<p>
				Pulleys can be troublesome when one side is fully
				extended. The rope on the other side will have zero
				length. At this point the constraint equations become
				singular (bad). Therefore the pulley joint constrains
				the maximum length that either side can attain. Also,
				you may want to control the maximum lengths for gameplay
				reasons. So the maximum lengths improve stability and
				give you more control.
			</p>
			<p>Here is an example pulley definition:</p>
			<pre class="programlisting">
Local anchor1:b2Vec2 = myBody1.GetWorldCenter()
Local anchor2:b2Vec2 = myBody2.GetWorldCenter()
Local groundAnchor1:b2Vec2 = new b2Vec2.Create(p1.X(), p1.Y() + 10.0)
Local groundAnchor2:b2Vec2 = new b2Vec2.Create(p2.X(), p2.Y() + 12.0)
Local ratio:Float = 1.0
Local jointDef:b2PulleyJointDef = new b2PulleyJointDef
jointDef.Initialize(myBody1, myBody2, groundAnchor1, groundAnchor2, anchor1, anchor2, ratio)
jointDef.SetMaxLength1(18.0)
jointDef.SetMaxLength2(20.0)
			</pre>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e1123"></a>
							7.2.5. Gear Joint
						</h3>
					</div>
				</div>
			</div>
			<p>
				If you want to create a sophisticated mechanical
				contraption you might want to use a gears. In principle
				you can create gears in Box2D by using compound shapes
				to model gear teeth. This is not very efficient and
				might be tedious to author. You also have to be careful
				to line up the gears so the teeth mesh smoothly. Box2D
				has a simpler method of creating gears: the
				<span class="emphasis">
					<em>gear joint</em>
				</span>
				.
			</p>
			<div class="informalfigure">
				<div class="mediaobject">
					<img src="images/gearJoint.gif"></div>
			</div>
			<p>
				The gear joint requires the you have two bodies
				connected to ground by a revolute or prismatic joint.
				You can use any combination of those joint types. Also,
				Box2D requires that the revolute and prismatic joints
				were created with the ground as body1.
			</p>
			<p>
				Like the pulley ratio, you can specify a gear ratio.
				However, in this case the gear ratio can be negative.
				Also keep in mind that when one joint is a revolute
				joint (angular) and the other joint is prismatic
				(translation), then the gear ratio with have units of
				length or one over length.
			</p>
			<pre class="programlisting">
coordinate1 + ratio * coordinate2 = constant
			</pre>
			<p>Here is an example gear joint:</p>
			<pre class="programlisting">
Local jointDef:b2GearJointDef = new b2GearJointDef
jointDef.SetBody1(myBody1)
jointDef.SetBody2(myBody2)
jointDef.SetJoint1(myRevoluteJoint)
jointDef.SetJoint2(myPrismaticJoint)
jointDef.SetRatio(2.0 * Pi / myLength)
			</pre>
			<p>
				Note that the gear joint depends on two other joints.
				This creates a fragile situation. What happens if those
				joints are deleted?
			</p>
			<div class="caution"
				style="margin-left: 0.5in; margin-right: 0.5in;">
				<h3 class="title">Caution</h3>
				<p>
					Always delete gear joints before the
					revolute/prismatic joints on the gears. Otherwise
					your code will crash in a bad way due to the
					orphaned joint references in the gear joint. You
					should also delete the gear joint before you delete
					any of the bodies involved.
				</p>
			</div>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e1150"></a>
							7.2.6. Mouse Joint
						</h3>
					</div>
				</div>
			</div>
			<p>
				The mouse joint is used in the examples to manipulate
				bodies with the mouse.
			</p>
		</div>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e1155"></a>
						7.3. Joint Factory
					</h2>
				</div>
			</div>
		</div>
		<p>
			Joints are created and destroyed using the world factory
			methods. This brings up an old issue:
		</p>
		<div class="caution"
			style="margin-left: 0.5in; margin-right: 0.5in;">
			<h3 class="title">Caution</h3>
			<p>
				You must create and destroy bodies and joints using
				the create and destroy methods of the
				<tt class="classname">b2World</tt>
				class.
			</p>
		</div>
		<p>Here's an example of the lifetime of a revolute joint:</p>
		<pre class="programlisting">
Local jointDef:b2RevoluteJointDef = new b2RevoluteJointDef
jointDef.SetBody1(myBody1)
jointDef.SetBody2(myBody2)
jointDef.SetAnchorPoint(myBody1.GetCenterPosition())
Local joint:b2RevoluteJoint = myWorld.CreateJoint(jointDef)
... do stuff ...
myWorld.DestroyJoint(joint)
joint = Null
		</pre>
		<p>
			It is always good to nullify your pointer after they are
			destroyed. This will make the program crash in a controlled
			manner if you try to reuse the pointer.
		</p>
		<p>
			The lifetime of a joint is not simple. Heed this warning
			well:
		</p>
		<div class="caution"
			style="margin-left: 0.5in; margin-right: 0.5in;">
			<h3 class="title">Caution</h3>
			<p>
				Joints are destroyed when an attached body is destroyed.
			</p>
		</div>
		<p>
			This precaution is not always necessary. You may organize
			your game engine so that joints are always destroyed before
			the attached bodies. In this case you don't need to
			implement the listener class. See
			<a href="#implicit_destruction"
				title="9.2 Implicit Destruction">
				Section 9.2, &quote;Implicit Destruction&quote;
			</a>
			for details.
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e1187"></a>
						7.4. Using Joints
					</h2>
				</div>
			</div>
		</div>
		<p>
			Many simulations create the joints and don't access them
			again until they are detroyed. However, there is a lot of
			useful data contained in joints that you can use to create a
			rich simulation.
		</p>
		<p>
			First of all, you can get the bodies, anchor points, and
			user data from a joint.
		</p>
		<pre class="programlisting">
Method GetBody1:b2Body()
Method GetBody2:b2Body()
Method GetAnchor1:b2Vec2()
Method GetAnchor2:b2Vec2()
Method GetUserData:Object()
		</pre>
		<p>
			All joints have a reaction force and torque. This the
			reaction force applied to body 2 at the anchor point. You
			can use reaction forces to break joints or trigger other
			game events. These functions may do some computations, so
			don't call them if you don't need the result.
		</p>
		<pre class="programlisting">
Method GetReactionForce:b2Vec2()
Method GetReactionTorque:Float()
		</pre>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e1200"></a>
							7.4.1. Using Distance Joints
						</h3>
					</div>
				</div>
			</div>
			<p>
				Distance joints don't have motors or limits, so there
				are no extra runtime methods for distance joints.
			</p>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e1205"></a>
							7.4.2. Using Revolute Joints
						</h3>
					</div>
				</div>
			</div>
			<p>
				You can access a revolute joint's angle, speed, and
				motor torque.
			</p>
			<pre class="programlisting">
Method GetJointAngle:Float()
Method GetJointSpeed:Float()
Method GetMotorTorque:Float()
			</pre>
			<p>You also update the motor parameters each step.</p>
			<pre class="programlisting">
Method SetMotorSpeed(speed:Float)
Method SetMaxMotorTorque(torque:Float)
			</pre>
			<p>
				Joint motors have some interesting abilities. You can
				update the joint speed every time step so you can make
				the joint move back-and-forth like a sine-wave or
				according to whatever function you want.
			</p>
			<pre class="programlisting">
... Game Loop Begin ...
myJoint.SetMotorSpeed(Cos(0.5 * time))
 ... Game Loop End ...
			</pre>
			<p>
				You can also use joint motors to track a desired joint
				angle. For example:
			</p>
			<pre class="programlisting">
... Game Loop Begin ...
Local angleError:Float = myJoint.GetJointAngle() - angleTarget
Local gain:Float = 0.1
myJoint.SetMotorSpeed(-gain * angleError)
... Game Loop End ...
			</pre>
			<p>
				Generally your gain parameter should not be too large.
				Otherwise your joint may become unstable.
			</p>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e1226"></a>
							7.4.3. Using Prismatic Joints
						</h3>
					</div>
				</div>
			</div>
			<p>
				Using a prismatic joint is similar to using a revolute
				joint. Here are the relevant member functions:
			</p>
			<pre class="programlisting">
Method GetJointTranslation:Float()
Method GetJointSpeed:Float()
Method GetMotorForce:Float()
Method SetMotorSpeed(speed:Float)
Method SetMotorForce(force:Float)
			</pre>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e1233"></a>
							7.4.4. Using Pulley Joints
						</h3>
					</div>
				</div>
			</div>
			<p>Pully joints provide the current lengths.</p>
			<pre class="programlisting">
Method GetLength1:Float()
Method GetLength2:Float()
			</pre>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e1240"></a>
							7.4.5. Using Gear Joints
						</h3>
					</div>
				</div>
			</div>
			<p>
				Gear joints don't provide any information beyond the
				functions defined in
				<tt class="classname">b2Joint</tt>
				.
			</p>
		</div>
		<div class="sect2" lang="en">
			<div class="titlepage">
				<div>
					<div>
						<h3 class="title">
							<a name="d0e1248"></a>
							7.4.6. Using Mouse Joints
						</h3>
					</div>
				</div>
			</div>
			<p>
				The mouse joint is able to manipulate the attached body
				by updating the target point each time step.
			</p>
		</div>
	</div>
</div>
<div class="chapter" lang="en">
	<div class="titlepage">
		<div>
			<div>
				<h2 class="title">
					<a name="d0e1253"></a>
					Chapter 8. Contacts
				</h2>
			</div>
		</div>
	</div>
	<div class="toc">
		<p>
			<b>Table of Contents</b>
		</p>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e1256">8.1. About</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e1310">8.2. Contact Listener</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e1359">8.3. Contact Filtering</a>
				</span>
			</dt>
		</dl>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e1256"></a>
						8.1. About
					</h2>
				</div>
			</div>
		</div>
		<p>
			Contacts are objects created by Box2D to manage collision
			between shapes. There are different kinds of contacts,
			derived from
			<tt class="classname">b2Contact</tt>
			, for managing contact between different kinds of shapes.
			For example there is a contact class for managing
			polygon-polygon collision and another contact class for
			managing circle-circle collision. This is normally not
			important to you, I just thought you might like to know.
		</p>
		<p>
			Here is some terminlogy associated with contacts. This
			terminology is particular to Box2D, but you might find
			similar terminology in other physics engines.
		</p>
		<div class="glosslist">
			<dl>
				<dt>contact point</dt>
				<dd>
					<p>
						A contact point is a point where two shapes
						touch. In reality objects may touch over regions
						when surfaces touch. Box2D approximates contact
						with a small number of points.
					</p>
				</dd>
				<dt>contact normal</dt>
				<dd>
					<p>
						A contact normal is a unit vector that points
						from shape1 to shape2.
					</p>
				</dd>
				<dt>contact separation</dt>
				<dd>
					<p>
						Separation is the opposite of penetration.
						Separation is negative when shapes overlap. It
						is possible that future versions of Box2D will
						create contact points with positive separation,
						so you may want to check the sign when contact
						points are reported.
					</p>
				</dd>
				<dt>normal force</dt>
				<dd>
					<p>
						Box2D use an iterative contact solver and stores
						the results with the contact points. You can
						safely use the normal force to guage the
						collision intensity. For example, you can use
						the force to trigger breakables or to play
						collision sounds.
					</p>
				</dd>
				<dt>tangent force</dt>
				<dd>
					<p>
						The tangent force is the contact solver's
						estimate of the friction force.
					</p>
				</dd>
				<dt>contact ids</dt>
				<dd>
					<p>
						Box2D tries to re-use the contact force results
						from a time step as the initial guess for the
						next time step. Box2D uses contact ids to match
						contact points across time steps. The ids
						contain geometric features indices that help to
						distinguish one contact point from another.
					</p>
				</dd>
			</dl>
		</div>
		<p>
			Contacts are created when two shape's AABBs overlap.
			Sometimes collision filtering will prevent the creation of
			contacts. Box2D sometimes needs to create a contact even
			though the collision is filtered. In this case it uses a
			<tt class="classname">b2NullContact</tt>
			that prevents collision from occuring. Contacts are
			destroyed with the AABBs cease to overlap.
		</p>
		<p>
			So you might gather that there may be contacts created for
			shapes that are not touching (just their AABBs). Well, this
			is correct. It's a "chicken or egg" problem. We don't know
			if we need a contact object until one is created to analyze
			the collision. We could delete the contact right away if the
			shapes are not touching, or we can just wait until the AABBS
			stop overlapping. Box2D takes the latter approach.
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e1310"></a>
						8.2. Contact Listener
					</h2>
				</div>
			</div>
		</div>
		<p>
			You can receive contact data by implementing
			<tt class="classname">b2ContactListener</tt>
			. This listener reports a contact point when it is created,
			when it persists for more than one time step, and when it is
			destroyed. Keep in mind that two shapes may have multiple
			contact points.
		</p>
		<pre class="programlisting">
Type MyContactListener Extends b2ContactListener
<p>
	Method Add(point:b2ContactPoint)
		' handle add point
	End Method
	
	Method Persist(point:b2ContactPoint)
		' handle persist point
	End Method
	
	Method Remove(point:b2ContactPoint)
		' handle remove point
	End Method
	
	Method Result(point:b2ContactResult)
		' handle results
	End Method
<p>
End Type
		</pre>
		<div class="caution"
			style="margin-left: 0.5in; margin-right: 0.5in;">
			<h3 class="title">Caution</h3>
			<p>
				Do not keep a reference to the contact points returned
				to
				<tt class="classname">b2ContactListener</tt>
				. Instead make a deep copy of the contact point data
				into your own buffer. The example below shows one way of
				doing this.
			</p>
		</div>
		<p>
			Continuous physics uses sub-stepping, so a contact point may
			be added and removed within the same time step. This is
			normally not a problem, but your code should handle this
			gracefully.
		</p>
		<p>
			Contact points are reported immediately when they are added,
			persisted, or removed. This occurs before the solver is
			called, so the
			<span class="structname">b2ContactPoint</span>
			object does not contain the computed impulse. However, the
			relative velocity at the contact point is provided so that
			you can estimated the contact impulse. If you implement the
			<tt class="function">Result</tt>
			listener function, you will receive
			<span class="structname">b2ContactResult</span>
			objects for solid contact points after the solver has been
			called. These result structures contain the sub-step
			impulses. Again, due to continuous physics you may receive
			multiple results per contact point per
			<tt class="function">b2World::DoStep</tt>
			.
		</p>
		<p>
			It is tempting to implement game logic that alters the
			physics world inside a contact callback. For example, you
			may have a collision that applies
			<span class="emphasis">
				<em>damage</em>
			</span>
			and try to destroy the associated actor and its rigid body.
			However, Box2D does not allow you to alter the physics world
			inside a callback because you might destroy objects that
			Box2D is currently processing, leading to orphaned references.
		</p>
		<p>
			The recommended practice for processing contact points is to
			buffer all contact points that you care about and process
			them after the time step. You should always process the
			contact points immediately after the time step, otherwise
			some other client code might alter the physics world,
			invalidating the contact buffer. When you process the
			contact point buffer you can alter the physics world, but
			you still need to be careful that you don't orphan references
			stored in the contact point buffer. The testbed has example
			contact point processing that is safe from orphaned
			references.
		</p>
		<p>
			This code from the CollisionProcessing test shows how to
			handle orphaned bodies when processing the contact buffer.
			Here is an excerpt. Be sure to read the comments in the
			listing. This code assumes that all contact points have been
			buffered in the
			<tt class="classname">b2ContactPoint</tt>
			array
			<tt class="varname">m_points</tt>
			.
		</p>
		<pre class="programlisting">
' We are going to destroy some bodies according to contact
' points. We must buffer the bodies that should be destroyed
' because they may belong to multiple contact points.
Local k_maxNuke:Int = 6
Local nuke:b2Body[] = new b2Body[k_maxNuke]
Local nukeCount:Int = 0
<p>
' Traverse the contact buffer. Destroy bodies that
' are touching heavier bodies.
For Local i:Int = 0 Until m_pointCount
<p>
	Local point:ContactPoint = m_points[i]
	
	Local body1:b2Body = point.GetShape1().GetBody()
	Local body2:b2Body = point.GetShape2().GetBody()
	Local mass1:Float = body1.GetMass()
	Local mass2:Float = body2.GetMass()
	
	If mass1 &gt; 0.0 And mass2 &gt; 0.0 Then
	
		If mass2 &gt; mass1 Then
			nuke[nukeCount] = body1
		Else
			nuke[nukeCount] = body2
		End If
		nukeCount:+ 1
	
		If nukeCount = k_maxNuke Then
			Exit
		End If
	
Next
<p>
' Sort the nuke array to group duplicates.
'std::sort(nuke, nuke + nukeCount); .. .TODO
<p>
' Destroy the bodies, skipping duplicates.
Local i:Int = 0
While i &lt; nukeCount
	Local b:b2Body = nuke[i]
	i:+ 1
	While i &lt; nukeCount And nuke[i] = b
		i:+ 1
	Wend
<p>
	m_world.DestroyBody(b)
Wend
<p>
		</pre>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e1359"></a>
						8.3. Contact Filtering
					</h2>
				</div>
			</div>
		</div>
		<p>
			Often in a game you don't want all objects to collide. For
			example, you may want to create a door that only certain
			characters can pass through. This is called contact
			filtering, because some interactions are
			<span class="emphasis">
				<em>filtered out</em>
			</span>
			.
		</p>
		<p>
			Box2D allows you to achieve custom contact filtering by
			implementing a
			<tt class="classname">b2ContactFilter</tt>
			class. This class requires you to implement a
			<tt class="methodname">ShouldCollide</tt>
			method that receives two
			<tt class="classname">b2Shape</tt>
			references. Your method returns true if the shapes should
			collide.
		</p>
		<p>
			The default implementation of
			<tt class="methodname">ShouldCollide</tt>
			uses the
			<span class="structname">b2FilterData</span>
			defined in
			<a href="#shapes" title="Chapter 6. Shapes">
				Chapter 6,
				<i>Shapes</i>
			</a>
			.
		</p>
		<pre class="programlisting">
Method ShouldCollide:Int(shape1:b2Shape, shape2:b2Shape)
<p>
	Local filter1:b2FilterData = shape1.GetFilterData()
	Local filter2:b2FilterData = shape2.GetFilterData()
<p>
	If filter1.GetGroupIndex() = filter2.GetGroupIndex() And filter1.GetGroupIndex() &lt;&gt; 0 Then
		return filter1.GetGroupIndex() &lt; $7FFF
	End If
<p>
	Local collide:Int = (filter1.GetMaskBits() &amp; filter2.GetCategoryBits()) &lt;&gt; 0 And ..
		(filter1.GetCategoryBits() &amp; filter2.GetMaskBits()) &lt;&gt; 0
	return collide
	
End Method
<p>
		</pre>
	</div>
</div>
<div class="chapter" lang="en">
	<div class="titlepage">
		<div>
			<div>
				<h2 class="title">
					<a name="d0e1390"></a>
					Chapter 9. Loose Ends
				</h2>
			</div>
		</div>
	</div>
	<div class="toc">
		<p>
			<b>Table of Contents</b>
		</p>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#world_boundary">9.1. World Boundary</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#implicit_destruction">
						9.2. Implicit Destruction
					</a>
				</span>
			</dt>
		</dl>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="world_boundary"></a>
						9.1. World Boundary
					</h2>
				</div>
			</div>
		</div>
		<p>
			You can implement a
			<tt class="classname">b2BoundaryListener</tt>
			that allows
			<tt class="classname">b2World</tt>
			to inform you when a body has gone outside the world AABB.
			When you get the callback, you shouldn't try to delete the
			body, instead you should mark the parent actor for deletion
			or error handling. After the physics time step, you should
			handle the event.
		</p>
		<pre class="programlisting">
Type MyBoundaryListener Extends b2BoundaryListener
<p>
	Method Violation(body:b2Body)
		Local myActor:MyActor = MyActor(body.GetUserData())
		myActor.MarkForErrorHandling()
	End Method
<p>
End Type
		</pre>
		<p>
			You can then register an instance of your boundary listener
			with your world object. You should do this during world
			initialization.
		</p>
		<pre class="programlisting">
myWorld.SetBoundaryListener(myBoundaryListener)
		</pre>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="implicit_destruction"></a>
						9.2. Implicit Destruction
					</h2>
				</div>
			</div>
		</div>
		<p>
			Box2D doesn't use reference counting. So if you destroy a
			body it is really gone. Accessing a pointer to a destroyed
			body has undefined behavior. In other words, your program
			will likely crash and burn. To help fix these problems, the
			debug build memory manager fills destroyed entities with
			<tt class="literal">FDFDFDFD</tt>
			. This can help find problems more easily in some cases.
		</p>
		<p>
			If you destroy a Box2D entity, it is up to you to make sure
			you remove all references to the destroyed object. This is
			easy if you only have a single reference to the entity. If
			you have multiple references, you might consider
			implementing a
			<span class="emphasis">
				<em>handle</em>
			</span>
			class to wrap the raw pointer.
		</p>
		<p>
			Often when using Box2D you will create and destroy many
			bodies, shapes, and joints. Managing these entities is
			somewhat automated by Box2D. If you destroy a body then all
			associated shapes and joints are automatically destroyed.
			This is called
			<span class="emphasis">
				<em>implicit destruction</em>
			</span>
			.
		</p>
		<p>
			When you destroy a body, all its attached shapes, joints,
			and contacts are destroyed. This is called
			<span class="emphasis">
				<em>implicit destruction</em>
			</span>
			. Any body connected to one of those joints and/or contacts
			is woken. This process is usually convenient. However, you
			must be aware of one crucial issue:
		</p>
		<div class="caution"
			style="margin-left: 0.5in; margin-right: 0.5in;">
			<h3 class="title">Caution</h3>
			<p>
				When a body is destroyed, all shapes and joints attached
				to the body are automatically destroyed. You must
				nullify any references you have to those shapes and
				joints. Otherwise, your program will
				<span class="emphasis">
					<em>die horribly</em>
				</span>
				if you try to access or destroy those shapes or joints
				later.
			</p>
		</div>
		<p>
			To help you nullify your joint references, Box2D provides a
			listener class named
			<tt class="classname">b2WorldListener</tt>
			that you can implement and provide to your world object.
			Then the world object will notify you when a joint is going
			to be implicity destroyed.
		</p>
		<p>
			Implicit destruction is a great convenience in many cases.
			It can also make your program fall apart. You may store
			references to shapes and joints somewhere in your code. These
			references become orphaned when an associated body is
			destroyed. The situation becomes worse when you consider
			that joints are often created by a part of the code
			unrelated to management of the associated body. For example,
			the testbed creates a
			<tt class="classname">b2MouseJoint</tt>
			for interactive manipulation of bodies on the screen.
		</p>
		<p>
			Box2D provides a callback mechanism to inform your
			application when implicit destruction occurs. This gives
			your application a chance to nullify the orphaned pointers.
			This callback mechanism is described later in this manual.
		</p>
		<p>
			You can implement a
			<tt class="classname">b2DestructionListener</tt>
			that allows
			<tt class="classname">b2World</tt>
			to inform you when a shape or joint is implicitly destroyed
			because an associated body was destroyed. This will help
			prevent your code from accessing orphaned pointers.
		</p>
		<pre class="programlisting">
Type MyDestructionListener Extends b2DestructionListener
<p>
	Method SayGoodbye(joint:b2Joint)
		' remove all references to joint.
	End Method
<p>
End Type
		</pre>
		<p>
			You can then register an instance of your destruction
			listener with your world object. You should do this during
			world initialization.
		</p>
		<pre class="programlisting">
myWorld.SetDestructionListener(myDestructionListener)
		</pre>
	</div>
</div>
<div class="chapter" lang="en">
	<div class="titlepage">
		<div>
			<div>
				<h2 class="title">
					<a name="d0e1465"></a>
					Chapter 10. Settings
				</h2>
			</div>
		</div>
	</div>
	<div class="toc">
		<p>
			<b>Table of Contents</b>
		</p>
		<dl>
			<dt>
				<span class="sect1">
					<a href="#d0e1468">10.1. About</a>
				</span>
			</dt>
			<dt>
				<span class="sect1">
					<a href="#d0e1481">10.2. Tolerances</a>
				</span>
			</dt>
		</dl>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e1468"></a>
						10.1. About
					</h2>
				</div>
			</div>
		</div>
		<p>
			There are two source files included in Box2D that are
			supplied specifically for user customization. These are
			<tt class="filename">b2Settings.h</tt>
			and
			<tt class="filename">b2Settings.cpp</tt>
			.
		</p>
		<p>
			Box2D works with floating point numbers, so some tolerances
			have to be used to make Box2D perform well.
		</p>
	</div>
	<div class="sect1" lang="en">
		<div class="titlepage">
			<div>
				<div>
					<h2 class="title" style="clear: both">
						<a name="d0e1481"></a>
						10.2. Tolerances
					</h2>
				</div>
			</div>
		</div>
		<p>
			There are many tolerances settings that depend on using MKS
			units. See
			<a href="#units" title="3.3. Units">
				Section 3.3, &#8220;Units&#8221;
			</a>
			for a deeper explanation of the unit system. See the doxygen
			docs for explanation of the individual tolerances.
		</p>
	</div>
</div>
<div class="chapter" lang="en">
	<div class="titlepage">
		<div>
			<div>
				<h2 class="title">
					<a name="d0e1513"></a>
					Chapter 11. Debug Drawing
				</h2>
			</div>
		</div>
	</div>
	<p>
		You can implement the
		<tt class="classname">b2DebugDraw</tt>
		class to get detailed drawing of the physics world. Here are the
		available entities:
	</p>
	<div class="itemizedlist">
		<ul type="disc">
			<li>
				<p>shape outlines</p>
			</li>
			<li>
				<p>joint connectivity</p>
			</li>
			<li>
				<p>core shapes (for continuous collision)</p>
			</li>
			<li>
				<p>
					broad-phase axis-aligned bounding boxes (AABBs),
					including the world AABB
				</p>
			</li>
			<li>
				<p>polygon oriented bounding boxes (OBBs)</p>
			</li>
			<li>
				<p>broad-phase pairs (potential contacts)</p>
			</li>
			<li>
				<p>center of mass</p>
			</li>
		</ul>
	</div>
	<p>
		This the preferred method of drawing these physics entities,
		rather than accessing the data directly. The reason is that much
		of the necessary data is internal and subject to change.
	</p>
	<p>
		The testbed draws physics entities using the debug draw facility
		and the contact listener, so it serves as the primary example of
		how to implement debug drawing as well as how to draw contact
		points.
	</p>
</div>
</div>
<h2><a name=functions></a>Functions Summary</h2><table class=doc width=100%>
<tr><td class=docleft width=1%><a href=#b2Cross>b2Cross</a></td><td class=docright>
Perform the cross product on a vector and a scalar.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2CrossF>b2CrossF</a></td><td class=docright>
Perform the cross product on a scalar and a vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2Dot>b2Dot</a></td><td class=docright>
Peform the dot product on two vectors.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2Mul>b2Mul</a></td><td class=docright>
Multiply a matrix times a vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2MulF>b2MulF</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#b2MulT>b2MulT</a></td><td class=docright>
Multiply a matrix transpose times a vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2MulTF>b2MulTF</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#Vec2>Vec2</a></td><td class=docright>
Convenience function for creating a b2Vec2 object.
</td></tr>
</table>
<h2><a name=types></a>Types Summary</h2><table class=doc width=100%>
<tr><td class=docleft width=1%><a href=#b2AABB>b2AABB</a></td><td class=docright>
An axis aligned bounding box.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2Body>b2Body</a></td><td class=docright>
Bodies are the backbone for shapes.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2BodyDef>b2BodyDef</a></td><td class=docright>
A body definition holds all the data needed to construct a rigid body.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2BoundaryListener>b2BoundaryListener</a></td><td class=docright>
Use this type for when a body's shape passes outside of the world boundary.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2BuoyancyController>b2BuoyancyController</a></td><td class=docright>
Calculates buoyancy forces for fluids in the form of a half plane.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2BuoyancyControllerDef>b2BuoyancyControllerDef</a></td><td class=docright>
Used to build buoyancy controllers.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2CircleDef>b2CircleDef</a></td><td class=docright>
Used to build circle shapes.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2CircleShape>b2CircleShape</a></td><td class=docright>
A circle shape.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2Color>b2Color</a></td><td class=docright>
Color for debug drawing.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2ConstantAccelController>b2ConstantAccelController</a></td><td class=docright>
Applies a force every frame.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2ConstantAccelControllerDef>b2ConstantAccelControllerDef</a></td><td class=docright>
Used to build constant acceleration controllers.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2ConstantForceController>b2ConstantForceController</a></td><td class=docright>
Applies a force every frame.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2ConstantForceControllerDef>b2ConstantForceControllerDef</a></td><td class=docright>
Used to build constant force controllers.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2Contact>b2Contact</a></td><td class=docright>
This type manages contact between two shapes.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2ContactFilter>b2ContactFilter</a></td><td class=docright>
Implement this type and override ShouldCollide() to provide collision filtering.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2ContactListener>b2ContactListener</a></td><td class=docright>
Implement this type to get collision results.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2ContactPoint>b2ContactPoint</a></td><td class=docright>
This type is used to report contact points.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2ContactResult>b2ContactResult</a></td><td class=docright>
This type is used to report contact point results.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2Controller>b2Controller</a></td><td class=docright>
Base type for controllers.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2ControllerEdge>b2ControllerEdge</a></td><td class=docright>
A controller edge is used to connect bodies and controllers together in a bipartite graph.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2DebugDraw>b2DebugDraw</a></td><td class=docright>
Implement and register this type with a b2World to provide debug drawing of physics entities in your game.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2DestructionListener>b2DestructionListener</a></td><td class=docright>
Joints and shapes are destroyed when their associated body is destroyed.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2DistanceJoint>b2DistanceJoint</a></td><td class=docright>
A distance joint constrains two points on two bodies to remain at a fixed distance from each other.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2DistanceJointDef>b2DistanceJointDef</a></td><td class=docright>
Distance joint definition.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2EdgeChainDef>b2EdgeChainDef</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#b2EdgeShape>b2EdgeShape</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#b2FilterData>b2FilterData</a></td><td class=docright>
This holds contact filtering data.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2GearJoint>b2GearJoint</a></td><td class=docright>
A gear joint is used to connect two joints together.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2GearJointDef>b2GearJointDef</a></td><td class=docright>
Gear joint definition.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2GravityController>b2GravityController</a></td><td class=docright>
Applies simplified gravity between every pair of bodies.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2GravityControllerDef>b2GravityControllerDef</a></td><td class=docright>
Used to build gravity controllers.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2Joint>b2Joint</a></td><td class=docright>
The base joint type.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2JointDef>b2JointDef</a></td><td class=docright>
Joint definitions are used to construct joints.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2JointEdge>b2JointEdge</a></td><td class=docright>
A joint edge is used to connect bodies and joints together in a joint graph where each body is a node and each joint is an edge.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2LineJoint>b2LineJoint</a></td><td class=docright>
A line joint.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2LineJointDef>b2LineJointDef</a></td><td class=docright>
Line joint definition.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2MassData>b2MassData</a></td><td class=docright>
Holds the mass data computed for a shape.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2Mat22>b2Mat22</a></td><td class=docright>
A 2-by-2 matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2MouseJoint>b2MouseJoint</a></td><td class=docright>
A mouse joint is used to make a point on a body track a specified world point.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2MouseJointDef>b2MouseJointDef</a></td><td class=docright>
Mouse joint definition.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2OBB>b2OBB</a></td><td class=docright>
An oriented bounding box.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2PolygonDef>b2PolygonDef</a></td><td class=docright>
Convex polygon.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2PolygonShape>b2PolygonShape</a></td><td class=docright>
A convex polygon.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2PrismaticJoint>b2PrismaticJoint</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#b2PrismaticJointDef>b2PrismaticJointDef</a></td><td class=docright>
Prismatic joint definition.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2PulleyJoint>b2PulleyJoint</a></td><td class=docright>
The pulley joint is connected to two bodies and two fixed ground points.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2PulleyJointDef>b2PulleyJointDef</a></td><td class=docright>
Pulley joint definition.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2RevoluteJoint>b2RevoluteJoint</a></td><td class=docright>
A revolute joint constrains to bodies to share a common point while they are free to rotate about the point.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2RevoluteJointDef>b2RevoluteJointDef</a></td><td class=docright>
Revolute joint definition.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2Segment>b2Segment</a></td><td class=docright>
A line segment.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2Shape>b2Shape</a></td><td class=docright>
A shape is used for collision detection.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2ShapeDef>b2ShapeDef</a></td><td class=docright>
A shape definition is used to construct a shape.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2TensorDampingController>b2TensorDampingController</a></td><td class=docright>
Applies top down linear damping to the controlled bodies.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2TensorDampingControllerDef>b2TensorDampingControllerDef</a></td><td class=docright>
Used to build tensor damping controllers.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2Vec2>b2Vec2</a></td><td class=docright>
A 2D column vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2World>b2World</a></td><td class=docright>
The world type manages all physics entities, dynamic simulation, and asynchronous queries.
</td></tr>
<tr><td class=docleft width=1%><a href=#b2XForm>b2XForm</a></td><td class=docright>
A transform contains translation and rotation.
</td></tr>
</table>
<h2
 id=functionsdet>Functions
</h2>
<table class=doc width=100% cellspacing=3 id=b2Cross>
<tr><td class=doctop colspan=2>Function b2Cross:b2Vec2(a:b2Vec2, s:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Perform the cross product on a vector and a scalar.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>In 2D this produces a vector.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2CrossF>
<tr><td class=doctop colspan=2>Function b2CrossF:b2Vec2(s:Float, a:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Perform the cross product on a scalar and a vector.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>In 2D this produces a vector.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2Dot>
<tr><td class=doctop colspan=2>Function b2Dot:Float(a:b2Vec2, b:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Peform the dot product on two vectors.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2Mul>
<tr><td class=doctop colspan=2>Function b2Mul:b2Vec2(A:b2Mat22, v:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply a matrix times a vector.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If a rotation matrix is provided, then this transforms the vector from one frame to another.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2MulF>
<tr><td class=doctop colspan=2>Function b2MulF:b2Vec2(T:b2XForm, v:b2Vec2)</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2MulT>
<tr><td class=doctop colspan=2>Function b2MulT:b2Vec2(A:b2Mat22, v:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiply a matrix transpose times a vector.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If a rotation matrix is provided, then this transforms the vector from one frame to another
(inverse transform).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2MulTF>
<tr><td class=doctop colspan=2>Function b2MulTF:b2Vec2(T:b2XForm, v:b2Vec2)</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=Vec2>
<tr><td class=doctop colspan=2>Function Vec2:b2Vec2(x:Float, y:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convenience function for creating a b2Vec2 object.</td></tr>
</table>
<br>
<h2
 id=typesdet>Types
</h2>
<table class=doc width=100% cellspacing=3 id=b2AABB>
<tr><td class=doctop colspan=2>Type b2AABB</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An axis aligned bounding box.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2AABB_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Creates a new AABB.
</td></tr>
<tr><td class=docleft width=1%><a href=#IsValid>IsValid</a></td><td class=docright>
Verify that the bounds are sorted.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLowerBound>SetLowerBound</a></td><td class=docright>
Sets the lower vertex.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetUpperBound>SetUpperBound</a></td><td class=docright>
Sets the upper vertex.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2AABB_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CreateAABB>CreateAABB</a></td><td class=docright>
Creates a new AABB.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Method Create:b2AABB(lowerBound:b2Vec2 = Null, upperBound:b2Vec2 = Null)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a new AABB.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsValid>
<tr><td class=doctop colspan=2>Method IsValid:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Verify that the bounds are sorted.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLowerBound>
<tr><td class=doctop colspan=2>Method SetLowerBound(lowerBound:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the lower vertex.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetUpperBound>
<tr><td class=doctop colspan=2>Method SetUpperBound(upperBound:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the upper vertex.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CreateAABB>
<tr><td class=doctop colspan=2>Function CreateAABB:b2AABB(lowerBound:b2Vec2 = Null, upperBound:b2Vec2 = Null)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a new AABB.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2Body>
<tr><td class=doctop colspan=2>Type b2Body</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Bodies are the backbone for shapes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Bodies carry shapes and move them around in the world. Bodies are always rigid bodies in Box2D. That
means that two shapes attached to the same rigid body never move relative to each other.
<p>
Bodies have position and velocity. You can apply forces, torques, and impulses to bodies. Bodies can be
static or dynamic. Static bodies never move and don't collide with other static bodies.
</p></td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2Body_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#AllowSleeping>AllowSleeping</a></td><td class=docright>
You can disable sleeping on this body.
</td></tr>
<tr><td class=docleft width=1%><a href=#ApplyForce>ApplyForce</a></td><td class=docright>
Apply a force at a world point.
</td></tr>
<tr><td class=docleft width=1%><a href=#ApplyImpulse>ApplyImpulse</a></td><td class=docright>
Apply an impulse at a point.
</td></tr>
<tr><td class=docleft width=1%><a href=#ApplyTorque>ApplyTorque</a></td><td class=docright>
Apply a torque.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateShape>CreateShape</a></td><td class=docright>
Creates a shape and attach it to this body.
</td></tr>
<tr><td class=docleft width=1%><a href=#DestroyShape>DestroyShape</a></td><td class=docright>
Destroy a shape.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetAngle>GetAngle</a></td><td class=docright>
Get the angle in degrees.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetAngularVelocity>GetAngularVelocity</a></td><td class=docright>
Get the angular velocity.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetInertia>GetInertia</a></td><td class=docright>
Get the central rotational inertia of the body.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetJointList>GetJointList</a></td><td class=docright>
Get the list of all joints attached to this body.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLinearVelocity>GetLinearVelocity</a></td><td class=docright>
Get the linear velocity of the center of mass.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalCenter>GetLocalCenter</a></td><td class=docright>
Get the Local position of the center of mass.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalPoint>GetLocalPoint</a></td><td class=docright>
Gets a local point relative to the body's origin given a world point.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalVector>GetLocalVector</a></td><td class=docright>
Gets a local vector given a world vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMass>GetMass</a></td><td class=docright>
Get the total mass of the body.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetNext>GetNext</a></td><td class=docright>
Get the next body in the world's body list.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetPosition>GetPosition</a></td><td class=docright>
Get the world body origin position.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetShapeList>GetShapeList</a></td><td class=docright>
Get the list of all shapes attached to this body.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetUserData>GetUserData</a></td><td class=docright>
Get the user data pointer that was provided in the body definition.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetWorld>GetWorld</a></td><td class=docright>
Get the parent world of this body.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetWorldCenter>GetWorldCenter</a></td><td class=docright>
Get the world position of the center of mass.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetWorldPoint>GetWorldPoint</a></td><td class=docright>
Get the world coordinates of a point given the local coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetWorldVector>GetWorldVector</a></td><td class=docright>
Get the world coordinates of a vector given the local coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetXForm>GetXForm</a></td><td class=docright>
Get the body transform for the body's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#IsBullet>IsBullet</a></td><td class=docright>
Is this body treated like a bullet for continuous collision detection?
</td></tr>
<tr><td class=docleft width=1%><a href=#IsDynamic>IsDynamic</a></td><td class=docright>
Is this body dynamic (movable)?
</td></tr>
<tr><td class=docleft width=1%><a href=#IsFrozen>IsFrozen</a></td><td class=docright>
Is this body frozen?
</td></tr>
<tr><td class=docleft width=1%><a href=#IsSleeping>IsSleeping</a></td><td class=docright>
Is this body sleeping (not simulating).
</td></tr>
<tr><td class=docleft width=1%><a href=#IsStatic>IsStatic</a></td><td class=docright>
Is this body static (immovable)?
</td></tr>
<tr><td class=docleft width=1%><a href=#PutToSleep>PutToSleep</a></td><td class=docright>
Put this body to sleep so it will stop simulating.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetAngularVelocity>SetAngularVelocity</a></td><td class=docright>
Set the angular velocity.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetBullet>SetBullet</a></td><td class=docright>
Should this body be treated like a bullet for continuous collision detection?
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLinearVelocity>SetLinearVelocity</a></td><td class=docright>
Set the linear velocity of the center of mass.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMass>SetMass</a></td><td class=docright>
Set the mass properties.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMassFromShapes>SetMassFromShapes</a></td><td class=docright>
Compute the mass properties from the attached shapes.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetXForm>SetXForm</a></td><td class=docright>
Set the position of the body's origin and rotation (degrees).
</td></tr>
<tr><td class=docleft width=1%><a href=#WakeUp>WakeUp</a></td><td class=docright>
Wake up this body so it will begin simulating.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=AllowSleeping>
<tr><td class=doctop colspan=2>Method AllowSleeping(flag:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>You can disable sleeping on this body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=ApplyForce>
<tr><td class=doctop colspan=2>Method ApplyForce(force:b2Vec2, point:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Apply a force at a world point.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If the force is not applied at the center of mass, it will generate a torque and affect the angular velocity.
This wakes up the body.
<p>Parameters:
<ul>
<li><b>force </b> : the world force vector, usually in Newtons (N).</li>
<li><b>point </b> : the world position of the point of application.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=ApplyImpulse>
<tr><td class=doctop colspan=2>Method ApplyImpulse(impulse:b2Vec2, point:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Apply an impulse at a point.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This immediately modifies the velocity.
It also modifies the angular velocity If the point of application is not at the center of mass. This wakes up the body.
<p>Parameters:
<ul>
<li><b> impulse </b> : the world impulse vector, usually in N-seconds Or kg-m/s.</li>
<li><b> point </b> : the world position of the point of application.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=ApplyTorque>
<tr><td class=doctop colspan=2>Method ApplyTorque(torque:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Apply a torque.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This affects the angular velocity without affecting the linear velocity of the center of mass.
This wakes up the body.
<p>Parameters:
<ul>
<li><b> torque </b> : about the z-axis (out of the screen), usually in N-m.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CreateShape>
<tr><td class=doctop colspan=2>Method CreateShape:b2Shape(def:b2ShapeDef)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a shape and attach it to this body.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Warning: This method is locked during callbacks.
<p>Parameters:
<ul>
<li><b>def </b> : the shape definition.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=DestroyShape>
<tr><td class=doctop colspan=2>Method DestroyShape(shape:b2Shape)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Destroy a shape.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This removes the shape from the broad-phase and therefore destroys any contacts associated with this shape.
All shapes attached to a body are implicitly destroyed when the body is destroyed.
<p>
Warning: This method is locked during callbacks.
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAngle>
<tr><td class=doctop colspan=2>Method GetAngle:Float()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The current world rotation angle in degrees.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the angle in degrees.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAngularVelocity>
<tr><td class=doctop colspan=2>Method GetAngularVelocity:Float()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The angular velocity in degrees/Second.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the angular velocity.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetInertia>
<tr><td class=doctop colspan=2>Method GetInertia:Float()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The rotational inertia, usually in kg-m^2.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the central rotational inertia of the body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetJointList>
<tr><td class=doctop colspan=2>Method GetJointList:b2JointEdge()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the list of all joints attached to this body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLinearVelocity>
<tr><td class=doctop colspan=2>Method GetLinearVelocity:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The linear velocity of the center of mass.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the linear velocity of the center of mass.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalCenter>
<tr><td class=doctop colspan=2>Method GetLocalCenter:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the Local position of the center of mass.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalPoint>
<tr><td class=doctop colspan=2>Method GetLocalPoint:b2Vec2(worldPoint:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The corresponding local point relative to the body's origin.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Gets a local point relative to the body's origin given a world point.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>worldPoint </b> : a point in world coordinates.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalVector>
<tr><td class=doctop colspan=2>Method GetLocalVector:b2Vec2(worldVector:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The corresponding local vector.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Gets a local vector given a world vector.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>worldVector </b> : a vector in world coordinates.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMass>
<tr><td class=doctop colspan=2>Method GetMass:Float()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The mass, usually in kilograms (kg).</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the total mass of the body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetNext>
<tr><td class=doctop colspan=2>Method GetNext:b2Body()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the next body in the world's body list.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetPosition>
<tr><td class=doctop colspan=2>Method GetPosition:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the world body origin position.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetShapeList>
<tr><td class=doctop colspan=2>Method GetShapeList:b2Shape()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the list of all shapes attached to this body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetUserData>
<tr><td class=doctop colspan=2>Method GetUserData:Object()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the user data pointer that was provided in the body definition.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetWorld>
<tr><td class=doctop colspan=2>Method GetWorld:b2World()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the parent world of this body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetWorldCenter>
<tr><td class=doctop colspan=2>Method GetWorldCenter:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the world position of the center of mass.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetWorldPoint>
<tr><td class=doctop colspan=2>Method GetWorldPoint:b2Vec2(localPoint:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The same point expressed in world coordinates.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the world coordinates of a point given the local coordinates.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>localPoint </b> : a point on the body measured relative the the body's origin.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetWorldVector>
<tr><td class=doctop colspan=2>Method GetWorldVector:b2Vec2(localVector:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The same vector expressed in world coordinates.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the world coordinates of a vector given the local coordinates.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>localVector </b> : a vector fixed in the body.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetXForm>
<tr><td class=doctop colspan=2>Method GetXForm:b2XForm()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the body transform for the body's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsBullet>
<tr><td class=doctop colspan=2>Method IsBullet:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is this body treated like a bullet for continuous collision detection?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsDynamic>
<tr><td class=doctop colspan=2>Method IsDynamic:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is this body dynamic (movable)?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsFrozen>
<tr><td class=doctop colspan=2>Method IsFrozen:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is this body frozen?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsSleeping>
<tr><td class=doctop colspan=2>Method IsSleeping:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is this body sleeping (not simulating).</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsStatic>
<tr><td class=doctop colspan=2>Method IsStatic:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is this body static (immovable)?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=PutToSleep>
<tr><td class=doctop colspan=2>Method PutToSleep()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Put this body to sleep so it will stop simulating.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This also sets the velocity to zero.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetAngularVelocity>
<tr><td class=doctop colspan=2>Method SetAngularVelocity(omega:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the angular velocity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>omega </b> : the New angular velocity in degrees/Second.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetBullet>
<tr><td class=doctop colspan=2>Method SetBullet(flag:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Should this body be treated like a bullet for continuous collision detection?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLinearVelocity>
<tr><td class=doctop colspan=2>Method SetLinearVelocity(v:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the linear velocity of the center of mass.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>v </b> : the New linear velocity of the center of mass.</li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMass>
<tr><td class=doctop colspan=2>Method SetMass(massData:b2MassData)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the mass properties.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Note that this changes the center of mass position.
<p>
If you are not sure how to compute mass properties, use SetMassFromShapes.
</p>
<p>
The inertia tensor is assumed to be relative to the center of mass.
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMassFromShapes>
<tr><td class=doctop colspan=2>Method SetMassFromShapes()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Compute the mass properties from the attached shapes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>You typically call this after adding all the shapes. If you add or remove shapes later, you may
want to call this again. Note that this changes the center of mass position.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetXForm>
<tr><td class=doctop colspan=2>Method SetXForm:Int(position:b2Vec2, angle:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the position of the body's origin and rotation (degrees).</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This breaks any contacts and wakes the other bodies.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=WakeUp>
<tr><td class=doctop colspan=2>Method WakeUp()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Wake up this body so it will begin simulating.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2BodyDef>
<tr><td class=doctop colspan=2>Type b2BodyDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A body definition holds all the data needed to construct a rigid body.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>You can safely re-use body definitions.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2BodyDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetAllowSleep>GetAllowSleep</a></td><td class=docright>
Returns true if the body is allowed to sleep.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetAngle>GetAngle</a></td><td class=docright>
Returns the world angle of the body in degrees.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetAngularDamping>GetAngularDamping</a></td><td class=docright>
Returns the angular damping.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetFixedRotation>GetFixedRotation</a></td><td class=docright>
Returns True if rotation is fixed.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetIsBullet>GetIsBullet</a></td><td class=docright>
Returns whether this is a bullet type body.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLinearDamping>GetLinearDamping</a></td><td class=docright>
Returns the linear damping.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMassData>GetMassData</a></td><td class=docright>
Returns mass property data.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetPosition>GetPosition</a></td><td class=docright>
Returns the world position of the body.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetUserData>GetUserData</a></td><td class=docright>
Returns the application specific body data, if any.
</td></tr>
<tr><td class=docleft width=1%><a href=#isSleeping>isSleeping</a></td><td class=docright>
Is this body initially sleeping?
</td></tr>
<tr><td class=docleft width=1%><a href=#SetAllowSleep>SetAllowSleep</a></td><td class=docright>
Set this flag to False if this body should never fall asleep.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetAngle>SetAngle</a></td><td class=docright>
The world angle of the body in degrees.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetAngularDamping>SetAngularDamping</a></td><td class=docright>
Angular damping is used to reduce the angular velocity.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFixedRotation>SetFixedRotation</a></td><td class=docright>
Should this body be prevented from rotating? Useful For characters.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetIsBullet>SetIsBullet</a></td><td class=docright>
Is this a fast moving body that should be prevented from tunneling through other moving bodies?
</td></tr>
<tr><td class=docleft width=1%><a href=#SetIsSleeping>SetIsSleeping</a></td><td class=docright>
Enables/Disables the sleeping state of the body.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLinearDamping>SetLinearDamping</a></td><td class=docright>
Linear damping is used to reduce the linear velocity.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMassData>SetMassData</a></td><td class=docright>
You can use this to initialize the mass properties of the body.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetPosition>SetPosition</a></td><td class=docright>
The world position of the body.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetPositionXY>SetPositionXY</a></td><td class=docright>
The world position of the body.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetUserData>SetUserData</a></td><td class=docright>
Use this to store application specific body data.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAllowSleep>
<tr><td class=doctop colspan=2>Method GetAllowSleep:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns true if the body is allowed to sleep.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAngle>
<tr><td class=doctop colspan=2>Method GetAngle:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the world angle of the body in degrees.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAngularDamping>
<tr><td class=doctop colspan=2>Method GetAngularDamping:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the angular damping.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetFixedRotation>
<tr><td class=doctop colspan=2>Method GetFixedRotation:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns True if rotation is fixed.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetIsBullet>
<tr><td class=doctop colspan=2>Method GetIsBullet:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns whether this is a bullet type body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLinearDamping>
<tr><td class=doctop colspan=2>Method GetLinearDamping:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the linear damping.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMassData>
<tr><td class=doctop colspan=2>Method GetMassData:b2MassData()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns mass property data.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetPosition>
<tr><td class=doctop colspan=2>Method GetPosition:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the world position of the body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetUserData>
<tr><td class=doctop colspan=2>Method GetUserData:Object()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the application specific body data, if any.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isSleeping>
<tr><td class=doctop colspan=2>Method isSleeping:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is this body initially sleeping?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetAllowSleep>
<tr><td class=doctop colspan=2>Method SetAllowSleep(allow:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set this flag to False if this body should never fall asleep.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Note that this increases CPU usage.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetAngle>
<tr><td class=doctop colspan=2>Method SetAngle(angle:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The world angle of the body in degrees.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetAngularDamping>
<tr><td class=doctop colspan=2>Method SetAngularDamping(damping:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Angular damping is used to reduce the angular velocity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The damping parameter can be larger than 1.0 but the damping effect becomes sensitive to the
time Step when the damping parameter is large.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetFixedRotation>
<tr><td class=doctop colspan=2>Method SetFixedRotation(fixed:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Should this body be prevented from rotating? Useful For characters.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetIsBullet>
<tr><td class=doctop colspan=2>Method SetIsBullet(bullet:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is this a fast moving body that should be prevented from tunneling through other moving bodies?</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Note that all bodies are prevented from tunneling through static bodies.
<p>
Warning: You should use this flag sparingly since it increases processing time.
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetIsSleeping>
<tr><td class=doctop colspan=2>Method SetIsSleeping(sleeping:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enables/Disables the sleeping state of the body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLinearDamping>
<tr><td class=doctop colspan=2>Method SetLinearDamping(damping:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Linear damping is used to reduce the linear velocity.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The damping parameter can be larger than 1.0 but the damping effect becomes sensitive To the
time Step when the damping parameter is large.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMassData>
<tr><td class=doctop colspan=2>Method SetMassData(data:b2MassData)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>You can use this to initialize the mass properties of the body.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>If you prefer, you can set the mass properties after the shapes have been added using b2Body.SetMassFromShapes.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetPosition>
<tr><td class=doctop colspan=2>Method SetPosition(position:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The world position of the body.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Avoid creating bodies at the origin since this can lead to many overlapping shapes.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetPositionXY>
<tr><td class=doctop colspan=2>Method SetPositionXY(x:Float, y:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The world position of the body.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Avoid creating bodies at the origin since this can lead to many overlapping shapes.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetUserData>
<tr><td class=doctop colspan=2>Method SetUserData(data:Object)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Use this to store application specific body data.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2BoundaryListener>
<tr><td class=doctop colspan=2>Type b2BoundaryListener</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Use this type for when a body's shape passes outside of the world boundary.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Override Violation().</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2BoundaryListener_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Violation>Violation</a></td><td class=docright>
This is called for each body that leaves the world boundary.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Violation>
<tr><td class=doctop colspan=2>Method Violation(body:b2Body)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>This is called for each body that leaves the world boundary.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Warning: you can't modify the world inside this callback.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2BuoyancyController>
<tr><td class=doctop colspan=2>Type b2BuoyancyController Extends b2Controller</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Calculates buoyancy forces for fluids in the form of a half plane.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2BuoyancyController_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetAngularDrag>GetAngularDrag</a></td><td class=docright>
Returns the angular drag co-efficient.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetDensity>GetDensity</a></td><td class=docright>
Returns the fluid density.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetGravity>GetGravity</a></td><td class=docright>
Returns the gravity vector, if the world's gravity is not used.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLinearDrag>GetLinearDrag</a></td><td class=docright>
Returns the linear drag co-efficient.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetNormal>GetNormal</a></td><td class=docright>
Returns the outer surface normal.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetOffset>GetOffset</a></td><td class=docright>
Returns the height of the fluid surface along the normal.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetVelocity>GetVelocity</a></td><td class=docright>
Returns the fluid velocity, for drag calculations.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetAngularDrag>SetAngularDrag</a></td><td class=docright>
Sets the angular drag co-efficient.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetDensity>SetDensity</a></td><td class=docright>
Sets the fluid density.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetGravity>SetGravity</a></td><td class=docright>
Returns the gravity vector, if the world's gravity is not used.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLinearDrag>SetLinearDrag</a></td><td class=docright>
Sets the linear drag co-efficient.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetNormal>SetNormal</a></td><td class=docright>
Sets the outer surface normal.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetOffset>SetOffset</a></td><td class=docright>
Sets the height of the fluid surface along the normal.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetUsesDensity>SetUsesDensity</a></td><td class=docright>
Set to False, if bodies are assumed to be uniformly dense, otherwise use the shapes densities.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetUsesWorldGravity>SetUsesWorldGravity</a></td><td class=docright>
Set to True, if gravity is to be taken from the world instead of the gravity parameter.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetVelocity>SetVelocity</a></td><td class=docright>
Sets the fluid velocity, for drag calculations.
</td></tr>
<tr><td class=docleft width=1%><a href=#UsesDensity>UsesDensity</a></td><td class=docright>
Returns False if bodies are assumed to be uniformly dense, otherwise use the shapes densities.
</td></tr>
<tr><td class=docleft width=1%><a href=#UsesWorldGravity>UsesWorldGravity</a></td><td class=docright>
Returns True, if gravity is taken from the world instead of the gravity parameter.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAngularDrag>
<tr><td class=doctop colspan=2>Method GetAngularDrag:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the angular drag co-efficient.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetDensity>
<tr><td class=doctop colspan=2>Method GetDensity:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the fluid density.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetGravity>
<tr><td class=doctop colspan=2>Method GetGravity:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the gravity vector, if the world's gravity is not used.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLinearDrag>
<tr><td class=doctop colspan=2>Method GetLinearDrag:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the linear drag co-efficient.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetNormal>
<tr><td class=doctop colspan=2>Method GetNormal:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the outer surface normal.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetOffset>
<tr><td class=doctop colspan=2>Method GetOffset:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the height of the fluid surface along the normal.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetVelocity>
<tr><td class=doctop colspan=2>Method GetVelocity:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the fluid velocity, for drag calculations.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetAngularDrag>
<tr><td class=doctop colspan=2>Method SetAngularDrag(drag:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the angular drag co-efficient.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetDensity>
<tr><td class=doctop colspan=2>Method SetDensity(density:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the fluid density.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetGravity>
<tr><td class=doctop colspan=2>Method SetGravity(gravity:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the gravity vector, if the world's gravity is not used.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLinearDrag>
<tr><td class=doctop colspan=2>Method SetLinearDrag(drag:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the linear drag co-efficient.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetNormal>
<tr><td class=doctop colspan=2>Method SetNormal(normal:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the outer surface normal.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetOffset>
<tr><td class=doctop colspan=2>Method SetOffset(offset:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the height of the fluid surface along the normal.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetUsesDensity>
<tr><td class=doctop colspan=2>Method SetUsesDensity(value:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set to False, if bodies are assumed to be uniformly dense, otherwise use the shapes densities.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetUsesWorldGravity>
<tr><td class=doctop colspan=2>Method SetUsesWorldGravity(value:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set to True, if gravity is to be taken from the world instead of the gravity parameter.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetVelocity>
<tr><td class=doctop colspan=2>Method SetVelocity(velocity:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the fluid velocity, for drag calculations.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=UsesDensity>
<tr><td class=doctop colspan=2>Method UsesDensity:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns False if bodies are assumed to be uniformly dense, otherwise use the shapes densities.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=UsesWorldGravity>
<tr><td class=doctop colspan=2>Method UsesWorldGravity:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns True, if gravity is taken from the world instead of the gravity parameter.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2BuoyancyControllerDef>
<tr><td class=doctop colspan=2>Type b2BuoyancyControllerDef Extends b2ControllerDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Used to build buoyancy controllers.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2BuoyancyControllerDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetAngularDrag>GetAngularDrag</a></td><td class=docright>
Returns the angular drag co-efficient.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetDensity>GetDensity</a></td><td class=docright>
Returns the fluid density.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetGravity>GetGravity</a></td><td class=docright>
Returns the gravity vector, if the world's gravity is not used.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLinearDrag>GetLinearDrag</a></td><td class=docright>
Returns the linear drag co-efficient.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetNormal>GetNormal</a></td><td class=docright>
Returns the outer surface normal.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetOffset>GetOffset</a></td><td class=docright>
Returns the height of the fluid surface along the normal.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetVelocity>GetVelocity</a></td><td class=docright>
Returns the fluid velocity, for drag calculations.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetAngularDrag>SetAngularDrag</a></td><td class=docright>
Sets the angular drag co-efficient.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetDensity>SetDensity</a></td><td class=docright>
Sets the fluid density.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetGravity>SetGravity</a></td><td class=docright>
Returns the gravity vector, if the world's gravity is not used.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLinearDrag>SetLinearDrag</a></td><td class=docright>
Sets the linear drag co-efficient.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetNormal>SetNormal</a></td><td class=docright>
Sets the outer surface normal.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetOffset>SetOffset</a></td><td class=docright>
Sets the height of the fluid surface along the normal.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetUsesDensity>SetUsesDensity</a></td><td class=docright>
Set to False, if bodies are assumed to be uniformly dense, otherwise use the shapes densities.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetUsesWorldGravity>SetUsesWorldGravity</a></td><td class=docright>
Set to True, if gravity is to be taken from the world instead of the gravity parameter.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetVelocity>SetVelocity</a></td><td class=docright>
Sets the fluid velocity, for drag calculations.
</td></tr>
<tr><td class=docleft width=1%><a href=#UsesDensity>UsesDensity</a></td><td class=docright>
Returns False if bodies are assumed to be uniformly dense, otherwise use the shapes densities.
</td></tr>
<tr><td class=docleft width=1%><a href=#UsesWorldGravity>UsesWorldGravity</a></td><td class=docright>
Returns True, if gravity is taken from the world instead of the gravity parameter.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAngularDrag>
<tr><td class=doctop colspan=2>Method GetAngularDrag:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the angular drag co-efficient.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetDensity>
<tr><td class=doctop colspan=2>Method GetDensity:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the fluid density.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetGravity>
<tr><td class=doctop colspan=2>Method GetGravity:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the gravity vector, if the world's gravity is not used.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLinearDrag>
<tr><td class=doctop colspan=2>Method GetLinearDrag:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the linear drag co-efficient.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetNormal>
<tr><td class=doctop colspan=2>Method GetNormal:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the outer surface normal.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetOffset>
<tr><td class=doctop colspan=2>Method GetOffset:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the height of the fluid surface along the normal.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetVelocity>
<tr><td class=doctop colspan=2>Method GetVelocity:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the fluid velocity, for drag calculations.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetAngularDrag>
<tr><td class=doctop colspan=2>Method SetAngularDrag(drag:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the angular drag co-efficient.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetDensity>
<tr><td class=doctop colspan=2>Method SetDensity(density:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the fluid density.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetGravity>
<tr><td class=doctop colspan=2>Method SetGravity(gravity:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the gravity vector, if the world's gravity is not used.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLinearDrag>
<tr><td class=doctop colspan=2>Method SetLinearDrag(drag:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the linear drag co-efficient.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetNormal>
<tr><td class=doctop colspan=2>Method SetNormal(normal:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the outer surface normal.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetOffset>
<tr><td class=doctop colspan=2>Method SetOffset(offset:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the height of the fluid surface along the normal.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetUsesDensity>
<tr><td class=doctop colspan=2>Method SetUsesDensity(value:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set to False, if bodies are assumed to be uniformly dense, otherwise use the shapes densities.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetUsesWorldGravity>
<tr><td class=doctop colspan=2>Method SetUsesWorldGravity(value:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set to True, if gravity is to be taken from the world instead of the gravity parameter.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetVelocity>
<tr><td class=doctop colspan=2>Method SetVelocity(velocity:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the fluid velocity, for drag calculations.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=UsesDensity>
<tr><td class=doctop colspan=2>Method UsesDensity:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns False if bodies are assumed to be uniformly dense, otherwise use the shapes densities.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=UsesWorldGravity>
<tr><td class=doctop colspan=2>Method UsesWorldGravity:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns True, if gravity is taken from the world instead of the gravity parameter.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2CircleDef>
<tr><td class=doctop colspan=2>Type b2CircleDef Extends b2ShapeDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Used to build circle shapes.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2CircleDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetLocalPosition>GetLocalPosition</a></td><td class=docright>
Returns the local position.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetRadius>GetRadius</a></td><td class=docright>
Returns the circle radius.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLocalPosition>SetLocalPosition</a></td><td class=docright>
Sets the local position.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetRadius>SetRadius</a></td><td class=docright>
Sets the circle radius.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalPosition>
<tr><td class=doctop colspan=2>Method GetLocalPosition:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the local position.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetRadius>
<tr><td class=doctop colspan=2>Method GetRadius:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the circle radius.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLocalPosition>
<tr><td class=doctop colspan=2>Method SetLocalPosition(pos:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the local position.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetRadius>
<tr><td class=doctop colspan=2>Method SetRadius(radius:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the circle radius.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2CircleShape>
<tr><td class=doctop colspan=2>Type b2CircleShape Extends b2Shape</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A circle shape.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2CircleShape_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetLocalPosition>GetLocalPosition</a></td><td class=docright>
Get the local position of this circle in its parent body.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetRadius>GetRadius</a></td><td class=docright>
Get the radius of this circle.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalPosition>
<tr><td class=doctop colspan=2>Method GetLocalPosition:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the local position of this circle in its parent body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetRadius>
<tr><td class=doctop colspan=2>Method GetRadius:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the radius of this circle.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2Color>
<tr><td class=doctop colspan=2>Type b2Color</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Color for debug drawing.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Each value has the range [0,1].</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2ConstantAccelController>
<tr><td class=doctop colspan=2>Type b2ConstantAccelController Extends b2Controller</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Applies a force every frame.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2ConstantAccelController_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetForce>GetForce</a></td><td class=docright>
Returns the force to apply.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetForce>SetForce</a></td><td class=docright>
Sets the force to apply.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetForce>
<tr><td class=doctop colspan=2>Method GetForce:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the force to apply.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetForce>
<tr><td class=doctop colspan=2>Method SetForce(force:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the force to apply.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2ConstantAccelControllerDef>
<tr><td class=doctop colspan=2>Type b2ConstantAccelControllerDef Extends b2ControllerDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Used to build constant acceleration controllers.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2ConstantAccelControllerDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetForce>GetForce</a></td><td class=docright>
Returns the force to apply.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetForce>SetForce</a></td><td class=docright>
Sets the force to apply.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetForce>
<tr><td class=doctop colspan=2>Method GetForce:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the force to apply.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetForce>
<tr><td class=doctop colspan=2>Method SetForce(force:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the force to apply.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2ConstantForceController>
<tr><td class=doctop colspan=2>Type b2ConstantForceController Extends b2Controller</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Applies a force every frame.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2ConstantForceController_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetForce>GetForce</a></td><td class=docright>
Returns the force to apply.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetForce>SetForce</a></td><td class=docright>
Sets the force to apply.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetForce>
<tr><td class=doctop colspan=2>Method GetForce:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the force to apply.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetForce>
<tr><td class=doctop colspan=2>Method SetForce(force:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the force to apply.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2ConstantForceControllerDef>
<tr><td class=doctop colspan=2>Type b2ConstantForceControllerDef Extends b2ControllerDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Used to build constant force controllers.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2ConstantForceControllerDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetForce>GetForce</a></td><td class=docright>
Returns the force to apply.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetForce>SetForce</a></td><td class=docright>
Sets the force to apply.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetForce>
<tr><td class=doctop colspan=2>Method GetForce:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the force to apply.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetForce>
<tr><td class=doctop colspan=2>Method SetForce(force:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the force to apply.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2Contact>
<tr><td class=doctop colspan=2>Type b2Contact</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>This type manages contact between two shapes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>A contact exists for each overlapping AABB in the broad-phase (except if filtered). Therefore a contact
object may exist that has no contact points.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2Contact_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetManifoldCount>GetManifoldCount</a></td><td class=docright>
Get the number of manifolds.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetNext>GetNext</a></td><td class=docright>
Get the next contact in the world's contact list.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetShape1>GetShape1</a></td><td class=docright>
Get the first shape in this contact.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetShape2>GetShape2</a></td><td class=docright>
Get the second shape in this contact.
</td></tr>
<tr><td class=docleft width=1%><a href=#IsSolid>IsSolid</a></td><td class=docright>
Is this contact solid?
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetManifoldCount>
<tr><td class=doctop colspan=2>Method GetManifoldCount:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the number of manifolds.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This is 0 or 1 between convex shapes.
This may be greater than 1 for convex-vs-concave shapes. Each
manifold holds up to two contact points with a shared contact normal.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetNext>
<tr><td class=doctop colspan=2>Method GetNext:b2Contact()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the next contact in the world's contact list.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetShape1>
<tr><td class=doctop colspan=2>Method GetShape1:b2Shape()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the first shape in this contact.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetShape2>
<tr><td class=doctop colspan=2>Method GetShape2:b2Shape()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the second shape in this contact.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsSolid>
<tr><td class=doctop colspan=2>Method IsSolid:Int()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>True if this contact should generate a response.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is this contact solid?</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2ContactFilter>
<tr><td class=doctop colspan=2>Type b2ContactFilter</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Implement this type and override ShouldCollide() to provide collision filtering.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>In other words, you can implement this type if you want finer control over contact creation.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2ContactFilter_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#ShouldCollide>ShouldCollide</a></td><td class=docright>
Return True if contact calculations should be performed between these two shapes.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=ShouldCollide>
<tr><td class=doctop colspan=2>Method ShouldCollide:Int(shape1:b2Shape, shape2:b2Shape)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Return True if contact calculations should be performed between these two shapes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Warning:  for performance reasons this is only called when the AABBs begin to overlap.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2ContactListener>
<tr><td class=doctop colspan=2>Type b2ContactListener</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Implement this type to get collision results.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>You can use these results for things like sounds and game logic. You can also get contact results by traversing
the contact lists after the time step. However, you might miss some contacts because continuous physics leads to
sub-stepping. Additionally you may receive multiple callbacks for the same contact in a single time step.
You should strive to make your callbacks efficient because there may be many callbacks per time step.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2ContactListener_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Add>Add</a></td><td class=docright>
Called when a contact point is added.
</td></tr>
<tr><td class=docleft width=1%><a href=#Persist>Persist</a></td><td class=docright>
Called when a contact point persists.
</td></tr>
<tr><td class=docleft width=1%><a href=#Remove>Remove</a></td><td class=docright>
Called when a contact point is removed.
</td></tr>
<tr><td class=docleft width=1%><a href=#Result>Result</a></td><td class=docright>
Called after a contact point is solved.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Add>
<tr><td class=doctop colspan=2>Method Add(point:b2ContactPoint)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Called when a contact point is added.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This includes the geometry and the forces.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Persist>
<tr><td class=doctop colspan=2>Method Persist(point:b2ContactPoint)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Called when a contact point persists.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This includes the geometry and the forces.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Remove>
<tr><td class=doctop colspan=2>Method Remove(point:b2ContactPoint)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Called when a contact point is removed.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This includes the last computed geometry and forces.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Result>
<tr><td class=doctop colspan=2>Method Result(result:b2ContactResult)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Called after a contact point is solved.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2ContactPoint>
<tr><td class=doctop colspan=2>Type b2ContactPoint</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>This type is used to report contact points.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2ContactPoint_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetFriction>GetFriction</a></td><td class=docright>
Returns the combined friction coefficient.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetNormal>GetNormal</a></td><td class=docright>
Points from shape1 to shape2.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetPosition>GetPosition</a></td><td class=docright>
Returns position in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetRestitution>GetRestitution</a></td><td class=docright>
Returns the combined restitution coefficient.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetSeparation>GetSeparation</a></td><td class=docright>
The separation is negative when shapes are touching.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetShape1>GetShape1</a></td><td class=docright>
Returns the first shape.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetShape2>GetShape2</a></td><td class=docright>
Returns the second shape.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetVelocity>GetVelocity</a></td><td class=docright>
Returns the velocity of point on body2 relative to point on body1 (pre-solver).
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetFriction>
<tr><td class=doctop colspan=2>Method GetFriction:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the combined friction coefficient.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetNormal>
<tr><td class=doctop colspan=2>Method GetNormal:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Points from shape1 to shape2.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetPosition>
<tr><td class=doctop colspan=2>Method GetPosition:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns position in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetRestitution>
<tr><td class=doctop colspan=2>Method GetRestitution:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the combined restitution coefficient.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetSeparation>
<tr><td class=doctop colspan=2>Method GetSeparation:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The separation is negative when shapes are touching.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetShape1>
<tr><td class=doctop colspan=2>Method GetShape1:b2Shape()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the first shape.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetShape2>
<tr><td class=doctop colspan=2>Method GetShape2:b2Shape()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the second shape.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetVelocity>
<tr><td class=doctop colspan=2>Method GetVelocity:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the velocity of point on body2 relative to point on body1 (pre-solver).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2ContactResult>
<tr><td class=doctop colspan=2>Type b2ContactResult</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>This type is used to report contact point results.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2ContactResult_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetNormal>GetNormal</a></td><td class=docright>
Points from shape1 to shape2.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetNormalImpulse>GetNormalImpulse</a></td><td class=docright>
Returns the normal impulse applied to body2.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetPosition>GetPosition</a></td><td class=docright>
Returns position in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetShape1>GetShape1</a></td><td class=docright>
Returns the first shape.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetShape2>GetShape2</a></td><td class=docright>
Returns the second shape.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetTangentImpulse>GetTangentImpulse</a></td><td class=docright>
Returns the tangent impulse applied to body2.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetNormal>
<tr><td class=doctop colspan=2>Method GetNormal:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Points from shape1 to shape2.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetNormalImpulse>
<tr><td class=doctop colspan=2>Method GetNormalImpulse:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the normal impulse applied to body2.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetPosition>
<tr><td class=doctop colspan=2>Method GetPosition:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns position in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetShape1>
<tr><td class=doctop colspan=2>Method GetShape1:b2Shape()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the first shape.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetShape2>
<tr><td class=doctop colspan=2>Method GetShape2:b2Shape()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the second shape.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetTangentImpulse>
<tr><td class=doctop colspan=2>Method GetTangentImpulse:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the tangent impulse applied to body2.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2Controller>
<tr><td class=doctop colspan=2>Type b2Controller</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Base type for controllers.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Controllers are a convience for encapsulating common per-step functionality.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2Controller_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#AddBody>AddBody</a></td><td class=docright>
Adds a body to the controller list.
</td></tr>
<tr><td class=docleft width=1%><a href=#Clear>Clear</a></td><td class=docright>
Removes all bodies from the controller list.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetBodyList>GetBodyList</a></td><td class=docright>
Get the attached body list.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetNext>GetNext</a></td><td class=docright>
Get the next controller in the world's body list.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetUserData>GetUserData</a></td><td class=docright>
Get the user data that was provided in the controller definition.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetWorld>GetWorld</a></td><td class=docright>
Get the parent world of this body.
</td></tr>
<tr><td class=docleft width=1%><a href=#RemoveBody>RemoveBody</a></td><td class=docright>
Removes a body from the controller list.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=AddBody>
<tr><td class=doctop colspan=2>Method AddBody(body:b2Body)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Adds a body to the controller list.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Clear>
<tr><td class=doctop colspan=2>Method Clear()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Removes all bodies from the controller list.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetBodyList>
<tr><td class=doctop colspan=2>Method GetBodyList:b2ControllerEdge()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the attached body list.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetNext>
<tr><td class=doctop colspan=2>Method GetNext:b2Controller()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the next controller in the world's body list.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetUserData>
<tr><td class=doctop colspan=2>Method GetUserData:Object()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the user data that was provided in the controller definition.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetWorld>
<tr><td class=doctop colspan=2>Method GetWorld:b2World()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the parent world of this body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=RemoveBody>
<tr><td class=doctop colspan=2>Method RemoveBody(body:b2Body)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Removes a body from the controller list.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2ControllerEdge>
<tr><td class=doctop colspan=2>Type b2ControllerEdge</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A controller edge is used to connect bodies and controllers together in a bipartite graph.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2ControllerEdge_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetBody>GetBody</a></td><td class=docright>
Returns the body.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetController>GetController</a></td><td class=docright>
Provides quick access to other end of this edge.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetNexBody>GetNexBody</a></td><td class=docright>
Returns the next controller edge in the controllers's joint list.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetNextController>GetNextController</a></td><td class=docright>
Returns the next controller edge in the body's joint list.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetPrevBody>GetPrevBody</a></td><td class=docright>
Returns the previous controller edge in the controllers's joint list.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetPrevController>GetPrevController</a></td><td class=docright>
Returns the previous controller edge in the body's joint list.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetBody>
<tr><td class=doctop colspan=2>Method GetBody:b2Body()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetController>
<tr><td class=doctop colspan=2>Method GetController:b2Controller()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Provides quick access to other end of this edge.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetNexBody>
<tr><td class=doctop colspan=2>Method GetNexBody:b2ControllerEdge()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the next controller edge in the controllers's joint list.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetNextController>
<tr><td class=doctop colspan=2>Method GetNextController:b2ControllerEdge()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the next controller edge in the body's joint list.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetPrevBody>
<tr><td class=doctop colspan=2>Method GetPrevBody:b2ControllerEdge()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the previous controller edge in the controllers's joint list.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetPrevController>
<tr><td class=doctop colspan=2>Method GetPrevController:b2ControllerEdge()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the previous controller edge in the body's joint list.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2DebugDraw>
<tr><td class=doctop colspan=2>Type b2DebugDraw</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Implement and register this type with a b2World to provide debug drawing of physics entities in your game.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2DebugDraw_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#AppendFlags>AppendFlags</a></td><td class=docright>
Append flags to the current flags.
</td></tr>
<tr><td class=docleft width=1%><a href=#ClearFlags>ClearFlags</a></td><td class=docright>
Clear flags from the current flags.
</td></tr>
<tr><td class=docleft width=1%><a href=#DrawCircle>DrawCircle</a></td><td class=docright>
Draw a circle.
</td></tr>
<tr><td class=docleft width=1%><a href=#DrawPolygon>DrawPolygon</a></td><td class=docright>
Draw a closed polygon provided in CCW order.
</td></tr>
<tr><td class=docleft width=1%><a href=#DrawSegment>DrawSegment</a></td><td class=docright>
Draw a line segment.
</td></tr>
<tr><td class=docleft width=1%><a href=#DrawSolidCircle>DrawSolidCircle</a></td><td class=docright>
Draw a solid circle.
</td></tr>
<tr><td class=docleft width=1%><a href=#DrawSolidPolygon>DrawSolidPolygon</a></td><td class=docright>
Draw a solid closed polygon provided in CCW order.
</td></tr>
<tr><td class=docleft width=1%><a href=#DrawXForm>DrawXForm</a></td><td class=docright>
Draw a transform. Choose your own length scale.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetFlags>GetFlags</a></td><td class=docright>
Get the drawing flags.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFlags>SetFlags</a></td><td class=docright>
Set the drawing flags.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=AppendFlags>
<tr><td class=doctop colspan=2>Method AppendFlags(flags:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Append flags to the current flags.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=ClearFlags>
<tr><td class=doctop colspan=2>Method ClearFlags(flags:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Clear flags from the current flags.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=DrawCircle>
<tr><td class=doctop colspan=2>Method DrawCircle(center:b2Vec2, radius:Float, color:b2Color) Abstract</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Draw a circle.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=DrawPolygon>
<tr><td class=doctop colspan=2>Method DrawPolygon(vertices:b2Vec2[], color:b2Color) Abstract</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Draw a closed polygon provided in CCW order.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=DrawSegment>
<tr><td class=doctop colspan=2>Method DrawSegment(p1:b2Vec2, p2:b2Vec2, color:b2Color) Abstract</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Draw a line segment.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=DrawSolidCircle>
<tr><td class=doctop colspan=2>Method DrawSolidCircle(center:b2Vec2, radius:Float, axis:b2Vec2, color:b2Color) Abstract</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Draw a solid circle.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=DrawSolidPolygon>
<tr><td class=doctop colspan=2>Method DrawSolidPolygon(vertices:b2Vec2[], color:b2Color) Abstract</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Draw a solid closed polygon provided in CCW order.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=DrawXForm>
<tr><td class=doctop colspan=2>Method DrawXForm(xf:b2XForm) Abstract</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Draw a transform. Choose your own length scale.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetFlags>
<tr><td class=doctop colspan=2>Method GetFlags:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the drawing flags.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetFlags>
<tr><td class=doctop colspan=2>Method SetFlags(flags:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the drawing flags.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2DestructionListener>
<tr><td class=doctop colspan=2>Type b2DestructionListener</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Joints and shapes are destroyed when their associated body is destroyed.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Implement this listener so that you may nullify references to these joints and shapes.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2DestructionListener_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#SayGoodbyeJoint>SayGoodbyeJoint</a></td><td class=docright>
Called when any joint is about to be destroyed due to the destruction of one of its attached bodies.
</td></tr>
<tr><td class=docleft width=1%><a href=#SayGoodbyeShape>SayGoodbyeShape</a></td><td class=docright>
Called when any shape is about to be destroyed due to the destruction of its parent body.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SayGoodbyeJoint>
<tr><td class=doctop colspan=2>Method SayGoodbyeJoint(joint:b2Joint)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Called when any joint is about to be destroyed due to the destruction of one of its attached bodies.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SayGoodbyeShape>
<tr><td class=doctop colspan=2>Method SayGoodbyeShape(shape:b2Shape)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Called when any shape is about to be destroyed due to the destruction of its parent body.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2DistanceJoint>
<tr><td class=doctop colspan=2>Type b2DistanceJoint Extends b2Joint</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A distance joint constrains two points on two bodies to remain at a fixed distance from each other.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>You can view this as a massless, rigid rod.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2DistanceJoint_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetAnchor1>GetAnchor1</a></td><td class=docright>
Get the anchor point on body1 in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetAnchor2>GetAnchor2</a></td><td class=docright>
Get the anchor point on body2 in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReactionForce>GetReactionForce</a></td><td class=docright>
Get the reaction force on body2 at the joint anchor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReactionTorque>GetReactionTorque</a></td><td class=docright>
Get the reaction torque on body2.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAnchor1>
<tr><td class=doctop colspan=2>Method GetAnchor1:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the anchor point on body1 in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAnchor2>
<tr><td class=doctop colspan=2>Method GetAnchor2:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the anchor point on body2 in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReactionForce>
<tr><td class=doctop colspan=2>Method GetReactionForce:b2Vec2(inv_dt:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the reaction force on body2 at the joint anchor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReactionTorque>
<tr><td class=doctop colspan=2>Method GetReactionTorque:Float(inv_dt:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the reaction torque on body2.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2DistanceJointDef>
<tr><td class=doctop colspan=2>Type b2DistanceJointDef Extends b2JointDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Distance joint definition.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This requires defining an anchor point on both bodies and the non-zero length of the
distance joint. The definition uses local anchor points so that the initial configuration can violate the
constraint slightly. This helps when saving and loading a game.
<p>
Warning: Do not use a zero or short length.
</p></td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2DistanceJointDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetLength>GetLength</a></td><td class=docright>
Returns the equilibrium length between the anchor points.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalAnchor1>GetLocalAnchor1</a></td><td class=docright>
Returns the local anchor point relative to body1's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalAnchor2>GetLocalAnchor2</a></td><td class=docright>
Returns the Local anchor point relative to body2's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#Initialize>Initialize</a></td><td class=docright>
Initialize the bodies, anchors, and length using the world anchors.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetDampingRatio>SetDampingRatio</a></td><td class=docright>
Sets the damping ratio. 0 = no damping, 1 = critical damping.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFrequencyHz>SetFrequencyHz</a></td><td class=docright>
Sets the response speed.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLength>SetLength</a></td><td class=docright>
Sets the equilibrium length between the anchor points.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLocalAnchor1>SetLocalAnchor1</a></td><td class=docright>
Sets the local anchor point relative to body1's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLocalAnchor2>SetLocalAnchor2</a></td><td class=docright>
Sets the Local anchor point relative to body2's origin.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLength>
<tr><td class=doctop colspan=2>Method GetLength:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the equilibrium length between the anchor points.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalAnchor1>
<tr><td class=doctop colspan=2>Method GetLocalAnchor1:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the local anchor point relative to body1's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalAnchor2>
<tr><td class=doctop colspan=2>Method GetLocalAnchor2:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the Local anchor point relative to body2's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Initialize>
<tr><td class=doctop colspan=2>Method Initialize(body1:b2Body, body2:b2Body, anchor1:b2Vec2, anchor2:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Initialize the bodies, anchors, and length using the world anchors.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetDampingRatio>
<tr><td class=doctop colspan=2>Method SetDampingRatio(ratio:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the damping ratio. 0 = no damping, 1 = critical damping.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetFrequencyHz>
<tr><td class=doctop colspan=2>Method SetFrequencyHz(freq:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the response speed.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLength>
<tr><td class=doctop colspan=2>Method SetLength(length:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the equilibrium length between the anchor points.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLocalAnchor1>
<tr><td class=doctop colspan=2>Method SetLocalAnchor1(anchor:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the local anchor point relative to body1's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLocalAnchor2>
<tr><td class=doctop colspan=2>Method SetLocalAnchor2(anchor:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the Local anchor point relative to body2's origin.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2EdgeChainDef>
<tr><td class=doctop colspan=2>Type b2EdgeChainDef Extends b2ShapeDef</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2EdgeChainDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetVertices>GetVertices</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#isALoop>isALoop</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#SetIsALoop>SetIsALoop</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#SetVertices>SetVertices</a></td><td class=docright>
&nbsp;
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetVertices>
<tr><td class=doctop colspan=2>Method GetVertices:b2Vec2[]()</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=isALoop>
<tr><td class=doctop colspan=2>Method isALoop:Int()</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetIsALoop>
<tr><td class=doctop colspan=2>Method SetIsALoop(value:Int)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetVertices>
<tr><td class=doctop colspan=2>Method SetVertices(vertices:b2Vec2[])</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2EdgeShape>
<tr><td class=doctop colspan=2>Type b2EdgeShape Extends b2Shape</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2FilterData>
<tr><td class=doctop colspan=2>Type b2FilterData</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>This holds contact filtering data.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2FilterData_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetCategoryBits>GetCategoryBits</a></td><td class=docright>
Returns the collision category bits.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetGroupIndex>GetGroupIndex</a></td><td class=docright>
Returns the collision group index.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMaskBits>GetMaskBits</a></td><td class=docright>
Returns the collision mask bits.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetCategoryBits>SetCategoryBits</a></td><td class=docright>
Sets the collision category bits.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetGroupIndex>SetGroupIndex</a></td><td class=docright>
Sets the collision group index.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMaskBits>SetMaskBits</a></td><td class=docright>
Sets the collision mask bits.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetCategoryBits>
<tr><td class=doctop colspan=2>Method GetCategoryBits:Short()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the collision category bits.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetGroupIndex>
<tr><td class=doctop colspan=2>Method GetGroupIndex:Short()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the collision group index.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Collision groups allow a certain group of objects to never collide (negative) or always collide (positive).
<p>
Zero means no collision group. Non-zero group filtering always wins against the mask bits.
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMaskBits>
<tr><td class=doctop colspan=2>Method GetMaskBits:Short()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the collision mask bits.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This states the categories that this shape would accept for collision.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetCategoryBits>
<tr><td class=doctop colspan=2>Method SetCategoryBits(categoryBits:Short)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the collision category bits.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Normally you would just set one bit.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetGroupIndex>
<tr><td class=doctop colspan=2>Method SetGroupIndex(index:Short)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the collision group index.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Collision groups allow a certain group of objects to never collide (negative) or always collide (positive).
<p>
Zero means no collision group. Non-zero group filtering always wins against the mask bits.
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMaskBits>
<tr><td class=doctop colspan=2>Method SetMaskBits(maskBits:Short)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the collision mask bits.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This states the categories that this shape would accept for collision.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2GearJoint>
<tr><td class=doctop colspan=2>Type b2GearJoint Extends b2Joint</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A gear joint is used to connect two joints together.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Either joint can be a revolute or prismatic joint. You specify a gear ratio to bind the motions
together:
<pre>
coordinate1 + ratio * coordinate2 = constant
</pre>
The ratio can be negative or positive. If one joint is a revolute joint and the other joint is a prismatic
joint, then the ratio will have units of length or units of 1/length.
<p>
Warning: The revolute and prismatic joints must be attached to fixed bodies (which must be body1 on those
joints).
</p></td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2GearJoint_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetAnchor1>GetAnchor1</a></td><td class=docright>
Get the anchor point on body1 in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetAnchor2>GetAnchor2</a></td><td class=docright>
Get the anchor point on body2 in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetRatio>GetRatio</a></td><td class=docright>
Get the gear ratio.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReactionForce>GetReactionForce</a></td><td class=docright>
Get the reaction force on body2 at the joint anchor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReactionTorque>GetReactionTorque</a></td><td class=docright>
Get the reaction torque on body2.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAnchor1>
<tr><td class=doctop colspan=2>Method GetAnchor1:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the anchor point on body1 in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAnchor2>
<tr><td class=doctop colspan=2>Method GetAnchor2:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the anchor point on body2 in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetRatio>
<tr><td class=doctop colspan=2>Method GetRatio:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the gear ratio.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReactionForce>
<tr><td class=doctop colspan=2>Method GetReactionForce:b2Vec2(inv_dt:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the reaction force on body2 at the joint anchor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReactionTorque>
<tr><td class=doctop colspan=2>Method GetReactionTorque:Float(inv_dt:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the reaction torque on body2.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2GearJointDef>
<tr><td class=doctop colspan=2>Type b2GearJointDef Extends b2JointDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Gear joint definition.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This definition requires two existing revolute or prismatic joints (any combination will work). The provided
joints must attach a dynamic body to a static body.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2GearJointDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#SetJoint1>SetJoint1</a></td><td class=docright>
Sets the first revolute/prismatic joint attached to the gear joint.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetJoint2>SetJoint2</a></td><td class=docright>
Sets the second revolute/prismatic joint attached to the gear joint.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetRatio>SetRatio</a></td><td class=docright>
Sets the gear ratio.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetJoint1>
<tr><td class=doctop colspan=2>Method SetJoint1(joint:b2Joint)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the first revolute/prismatic joint attached to the gear joint.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetJoint2>
<tr><td class=doctop colspan=2>Method SetJoint2(joint:b2Joint)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the second revolute/prismatic joint attached to the gear joint.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetRatio>
<tr><td class=doctop colspan=2>Method SetRatio(ratio:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the gear ratio.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2GravityController>
<tr><td class=doctop colspan=2>Type b2GravityController Extends b2Controller</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Applies simplified gravity between every pair of bodies.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2GravityController_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetForce>GetForce</a></td><td class=docright>
Returns the strength of the gravitiation force.
</td></tr>
<tr><td class=docleft width=1%><a href=#IsInvSqr>IsInvSqr</a></td><td class=docright>
Returns whether gravity is proportional to r^-2 (True), otherwise r^-1 (False).
</td></tr>
<tr><td class=docleft width=1%><a href=#SetForce>SetForce</a></td><td class=docright>
Sets the strength of the gravitiation force.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetIsInvSqr>SetIsInvSqr</a></td><td class=docright>
Sets whether gravity is proportional to r^-2 (True), otherwise r^-1 (False).
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetForce>
<tr><td class=doctop colspan=2>Method GetForce:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the strength of the gravitiation force.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsInvSqr>
<tr><td class=doctop colspan=2>Method IsInvSqr:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns whether gravity is proportional to r^-2 (True), otherwise r^-1 (False).</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetForce>
<tr><td class=doctop colspan=2>Method SetForce(force:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the strength of the gravitiation force.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetIsInvSqr>
<tr><td class=doctop colspan=2>Method SetIsInvSqr(value:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets whether gravity is proportional to r^-2 (True), otherwise r^-1 (False).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2GravityControllerDef>
<tr><td class=doctop colspan=2>Type b2GravityControllerDef Extends b2ControllerDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Used to build gravity controllers.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2GravityControllerDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetForce>GetForce</a></td><td class=docright>
Returns the strength of the gravitiation force.
</td></tr>
<tr><td class=docleft width=1%><a href=#IsInvSqr>IsInvSqr</a></td><td class=docright>
Returns whether gravity is proportional to r^-2 (True), otherwise r^-1 (False).
</td></tr>
<tr><td class=docleft width=1%><a href=#SetForce>SetForce</a></td><td class=docright>
Sets the strength of the gravitiation force.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetIsInvSqr>SetIsInvSqr</a></td><td class=docright>
Sets whether gravity is proportional to r^-2 (True), otherwise r^-1 (False).
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetForce>
<tr><td class=doctop colspan=2>Method GetForce:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the strength of the gravitiation force.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsInvSqr>
<tr><td class=doctop colspan=2>Method IsInvSqr:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns whether gravity is proportional to r^-2 (True), otherwise r^-1 (False).</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetForce>
<tr><td class=doctop colspan=2>Method SetForce(force:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the strength of the gravitiation force.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetIsInvSqr>
<tr><td class=doctop colspan=2>Method SetIsInvSqr(value:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets whether gravity is proportional to r^-2 (True), otherwise r^-1 (False).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2Joint>
<tr><td class=doctop colspan=2>Type b2Joint</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The base joint type.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Joints are used to constraint two bodies together in various fashions.
Some joints also feature limits and motors.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2Joint_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetBody1>GetBody1</a></td><td class=docright>
Get the first body attached to this joint.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetBody2>GetBody2</a></td><td class=docright>
Get the second body attached to this joint.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetNext>GetNext</a></td><td class=docright>
Get the next joint the world joint list.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetUserData>GetUserData</a></td><td class=docright>
Get the user data pointer that was provided in the joint definition.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetBody1>
<tr><td class=doctop colspan=2>Method GetBody1:b2Body()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the first body attached to this joint.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetBody2>
<tr><td class=doctop colspan=2>Method GetBody2:b2Body()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the second body attached to this joint.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetNext>
<tr><td class=doctop colspan=2>Method GetNext:b2Joint()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the next joint the world joint list.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetUserData>
<tr><td class=doctop colspan=2>Method GetUserData:Object()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the user data pointer that was provided in the joint definition.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2JointDef>
<tr><td class=doctop colspan=2>Type b2JointDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Joint definitions are used to construct joints.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2JointDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetBody1>GetBody1</a></td><td class=docright>
Returns the first attached body.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetBody2>GetBody2</a></td><td class=docright>
Returns the second attached body.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetCollideConnected>GetCollideConnected</a></td><td class=docright>
Returns True if the attached bodies should collide.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetBody1>SetBody1</a></td><td class=docright>
The First attached body.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetBody2>SetBody2</a></td><td class=docright>
The Second attached body.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetCollideConnected>SetCollideConnected</a></td><td class=docright>
Set this flag to True if the attached bodies should collide.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetBody1>
<tr><td class=doctop colspan=2>Method GetBody1:b2Body()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the first attached body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetBody2>
<tr><td class=doctop colspan=2>Method GetBody2:b2Body()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the second attached body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetCollideConnected>
<tr><td class=doctop colspan=2>Method GetCollideConnected:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns True if the attached bodies should collide.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetBody1>
<tr><td class=doctop colspan=2>Method SetBody1(body:b2Body)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The First attached body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetBody2>
<tr><td class=doctop colspan=2>Method SetBody2(body:b2Body)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The Second attached body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetCollideConnected>
<tr><td class=doctop colspan=2>Method SetCollideConnected(collideConnected:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set this flag to True if the attached bodies should collide.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2JointEdge>
<tr><td class=doctop colspan=2>Type b2JointEdge</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A joint edge is used to connect bodies and joints together in a joint graph where each body is a node and each joint is an edge.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>A joint edge belongs to a doubly linked list maintained in each attached body. Each joint has two
joint nodes, one for each attached body.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2JointEdge_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetJoint>GetJoint</a></td><td class=docright>
Returns the joint.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetNext>GetNext</a></td><td class=docright>
Returns the next joint edge in the body's joint list.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetOther>GetOther</a></td><td class=docright>
Provides quick access to the other body attached.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetPrev>GetPrev</a></td><td class=docright>
Returns the previous joint edge in the body's joint list.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetJoint>
<tr><td class=doctop colspan=2>Method GetJoint:b2Joint()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the joint.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetNext>
<tr><td class=doctop colspan=2>Method GetNext:b2JointEdge()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the next joint edge in the body's joint list.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetOther>
<tr><td class=doctop colspan=2>Method GetOther:b2Body()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Provides quick access to the other body attached.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetPrev>
<tr><td class=doctop colspan=2>Method GetPrev:b2JointEdge()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the previous joint edge in the body's joint list.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2LineJoint>
<tr><td class=doctop colspan=2>Type b2LineJoint Extends b2Joint</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A line joint.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This joint provides one degree of freedom: translation along an axis fixed in body1. You can use a joint limit to restrict
the range of motion and a joint motor to drive the motion or to model joint friction.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2LineJoint_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#EnableLimit>EnableLimit</a></td><td class=docright>
Enable/disable the joint limit.
</td></tr>
<tr><td class=docleft width=1%><a href=#EnableMotor>EnableMotor</a></td><td class=docright>
Enable/disable the joint motor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetAnchor1>GetAnchor1</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#GetAnchor2>GetAnchor2</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#GetJointSpeed>GetJointSpeed</a></td><td class=docright>
Get the current joint translation speed, usually in meters per second.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetJointTranslation>GetJointTranslation</a></td><td class=docright>
Get the current joint translation, usually in meters.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLowerLimit>GetLowerLimit</a></td><td class=docright>
Get the lower joint limit, usually in meters.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMotorForce>GetMotorForce</a></td><td class=docright>
Get the current motor force, usually in N.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMotorSpeed>GetMotorSpeed</a></td><td class=docright>
Get the motor speed, usually in meters per second.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReactionForce>GetReactionForce</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReactionTorque>GetReactionTorque</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#GetUpperLimit>GetUpperLimit</a></td><td class=docright>
Get the upper joint limit, usually in meters.
</td></tr>
<tr><td class=docleft width=1%><a href=#IsLimitEnabled>IsLimitEnabled</a></td><td class=docright>
Is the joint limit enabled?
</td></tr>
<tr><td class=docleft width=1%><a href=#IsMotorEnabled>IsMotorEnabled</a></td><td class=docright>
Is the joint motor enabled?
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLimits>SetLimits</a></td><td class=docright>
Set the joint limits, usually in meters.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMaxMotorForce>SetMaxMotorForce</a></td><td class=docright>
Set the maximum motor force, usually in N.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMotorSpeed>SetMotorSpeed</a></td><td class=docright>
Set the motor speed, usually in meters per second.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=EnableLimit>
<tr><td class=doctop colspan=2>Method EnableLimit(flag:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enable/disable the joint limit.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=EnableMotor>
<tr><td class=doctop colspan=2>Method EnableMotor(flag:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enable/disable the joint motor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAnchor1>
<tr><td class=doctop colspan=2>Method GetAnchor1:b2Vec2()</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAnchor2>
<tr><td class=doctop colspan=2>Method GetAnchor2:b2Vec2()</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetJointSpeed>
<tr><td class=doctop colspan=2>Method GetJointSpeed:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the current joint translation speed, usually in meters per second.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetJointTranslation>
<tr><td class=doctop colspan=2>Method GetJointTranslation:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the current joint translation, usually in meters.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLowerLimit>
<tr><td class=doctop colspan=2>Method GetLowerLimit:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the lower joint limit, usually in meters.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMotorForce>
<tr><td class=doctop colspan=2>Method GetMotorForce:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the current motor force, usually in N.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMotorSpeed>
<tr><td class=doctop colspan=2>Method GetMotorSpeed:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the motor speed, usually in meters per second.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReactionForce>
<tr><td class=doctop colspan=2>Method GetReactionForce:b2Vec2(inv_dt:Float)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReactionTorque>
<tr><td class=doctop colspan=2>Method GetReactionTorque:Float(inv_dt:Float)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetUpperLimit>
<tr><td class=doctop colspan=2>Method GetUpperLimit:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the upper joint limit, usually in meters.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsLimitEnabled>
<tr><td class=doctop colspan=2>Method IsLimitEnabled:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is the joint limit enabled?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsMotorEnabled>
<tr><td class=doctop colspan=2>Method IsMotorEnabled:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is the joint motor enabled?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLimits>
<tr><td class=doctop colspan=2>Method SetLimits(_lower:Float, _upper:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the joint limits, usually in meters.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMaxMotorForce>
<tr><td class=doctop colspan=2>Method SetMaxMotorForce(force:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the maximum motor force, usually in N.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMotorSpeed>
<tr><td class=doctop colspan=2>Method SetMotorSpeed(speed:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the motor speed, usually in meters per second.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2LineJointDef>
<tr><td class=doctop colspan=2>Type b2LineJointDef Extends b2JointDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Line joint definition.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This requires defining a line of motion using an axis and an anchor point. The definition uses local
anchor points and a local axis so that the initial configuration can violate the constraint slightly. The joint translation is zero
when the local anchor points coincide in world space. Using local anchors and a local axis helps when saving and loading a game.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2LineJointDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#EnableLimit>EnableLimit</a></td><td class=docright>
Enables/disables the joint limit.
</td></tr>
<tr><td class=docleft width=1%><a href=#EnableMotor>EnableMotor</a></td><td class=docright>
Enables/disables the joint motor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLimit>GetLimit</a></td><td class=docright>
Returns the joint limit.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalAnchor1>GetLocalAnchor1</a></td><td class=docright>
Returns the local anchor point relative to body1's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalAnchor2>GetLocalAnchor2</a></td><td class=docright>
Returns the Local anchor point relative to body2's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalAxis1>GetLocalAxis1</a></td><td class=docright>
Returns the local translation axis in body1.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLowerTranslation>GetLowerTranslation</a></td><td class=docright>
Gets the lower translation limit, usually in meters.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMaxMotorForce>GetMaxMotorForce</a></td><td class=docright>
Returns the maximum motor torque, usually in N-m.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMotorSpeed>GetMotorSpeed</a></td><td class=docright>
Returns the desired motor speed, in degrees per second.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetUpperTranslation>GetUpperTranslation</a></td><td class=docright>
Gets the upper translation limit, usually in meters.
</td></tr>
<tr><td class=docleft width=1%><a href=#Initialize>Initialize</a></td><td class=docright>
Initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.
</td></tr>
<tr><td class=docleft width=1%><a href=#IsMotorEnabled>IsMotorEnabled</a></td><td class=docright>
Is the motor enabled?
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLocalAnchor1>SetLocalAnchor1</a></td><td class=docright>
Sets the local anchor point relative to body1's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLocalAnchor2>SetLocalAnchor2</a></td><td class=docright>
Sets the Local anchor point relative to body2's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLocalAxis1>SetLocalAxis1</a></td><td class=docright>
Sets the local translation axis in body1.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLowerTranslation>SetLowerTranslation</a></td><td class=docright>
Sets the lower translation limit, usually in meters.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMaxMotorForce>SetMaxMotorForce</a></td><td class=docright>
Sets the maximum motor torque, usually in N-m.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMotorSpeed>SetMotorSpeed</a></td><td class=docright>
Sets the desired motor speed, in degrees per second.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetUpperTranslation>SetUpperTranslation</a></td><td class=docright>
Sets the upper translation limit, usually in meters.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=EnableLimit>
<tr><td class=doctop colspan=2>Method EnableLimit(limit:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enables/disables the joint limit.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=EnableMotor>
<tr><td class=doctop colspan=2>Method EnableMotor(enable:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enables/disables the joint motor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLimit>
<tr><td class=doctop colspan=2>Method GetLimit:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the joint limit.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalAnchor1>
<tr><td class=doctop colspan=2>Method GetLocalAnchor1:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the local anchor point relative to body1's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalAnchor2>
<tr><td class=doctop colspan=2>Method GetLocalAnchor2:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the Local anchor point relative to body2's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalAxis1>
<tr><td class=doctop colspan=2>Method GetLocalAxis1:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the local translation axis in body1.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLowerTranslation>
<tr><td class=doctop colspan=2>Method GetLowerTranslation:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Gets the lower translation limit, usually in meters.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMaxMotorForce>
<tr><td class=doctop colspan=2>Method GetMaxMotorForce:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the maximum motor torque, usually in N-m.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMotorSpeed>
<tr><td class=doctop colspan=2>Method GetMotorSpeed:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the desired motor speed, in degrees per second.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetUpperTranslation>
<tr><td class=doctop colspan=2>Method GetUpperTranslation:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Gets the upper translation limit, usually in meters.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Initialize>
<tr><td class=doctop colspan=2>Method Initialize(body1:b2Body, body2:b2Body, anchor:b2Vec2, axis:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsMotorEnabled>
<tr><td class=doctop colspan=2>Method IsMotorEnabled:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is the motor enabled?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLocalAnchor1>
<tr><td class=doctop colspan=2>Method SetLocalAnchor1(anchor:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the local anchor point relative to body1's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLocalAnchor2>
<tr><td class=doctop colspan=2>Method SetLocalAnchor2(anchor:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the Local anchor point relative to body2's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLocalAxis1>
<tr><td class=doctop colspan=2>Method SetLocalAxis1(axis:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the local translation axis in body1.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLowerTranslation>
<tr><td class=doctop colspan=2>Method SetLowerTranslation(translation:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the lower translation limit, usually in meters.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMaxMotorForce>
<tr><td class=doctop colspan=2>Method SetMaxMotorForce(maxForce:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the maximum motor torque, usually in N-m.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMotorSpeed>
<tr><td class=doctop colspan=2>Method SetMotorSpeed(speed:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the desired motor speed, in degrees per second.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetUpperTranslation>
<tr><td class=doctop colspan=2>Method SetUpperTranslation(translation:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the upper translation limit, usually in meters.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2MassData>
<tr><td class=doctop colspan=2>Type b2MassData</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Holds the mass data computed for a shape.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2MassData_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#SetCenter>SetCenter</a></td><td class=docright>
Sets the position of the shape's centroid relative to the shape's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMass>SetMass</a></td><td class=docright>
Sets the mass of the shape, usually in kilograms.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetRotationalInertia>SetRotationalInertia</a></td><td class=docright>
Sets the rotational inertia of the shape.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetCenter>
<tr><td class=doctop colspan=2>Method SetCenter(center:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the position of the shape's centroid relative to the shape's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMass>
<tr><td class=doctop colspan=2>Method SetMass(mass:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the mass of the shape, usually in kilograms.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetRotationalInertia>
<tr><td class=doctop colspan=2>Method SetRotationalInertia(i:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the rotational inertia of the shape.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2Mat22>
<tr><td class=doctop colspan=2>Type b2Mat22</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A 2-by-2 matrix.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Stored in column-major order.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2Mat22_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Constructs the matrix using scalars.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateAngle>CreateAngle</a></td><td class=docright>
Constructs the matrix using an angle.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateVec>CreateVec</a></td><td class=docright>
Constructs the matrix using columns.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetAngle>GetAngle</a></td><td class=docright>
Returns the angle.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetInverse>GetInverse</a></td><td class=docright>
Computes the inverse of this matrix, such that inv(A) * A = identity.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetAngle>SetAngle</a></td><td class=docright>
Initialize this matrix using an angle.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetIdentity>SetIdentity</a></td><td class=docright>
Set this to the identity matrix.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetZero>SetZero</a></td><td class=docright>
Set this matrix to all zeros.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Method Create:b2Mat22(a11:Float = 0, a12:Float = 0, a21:Float = 0, a22:Float = 0)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Constructs the matrix using scalars.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CreateAngle>
<tr><td class=doctop colspan=2>Method CreateAngle:b2Mat22(angle:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Constructs the matrix using an angle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This matrix becomes an orthonormal rotation matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CreateVec>
<tr><td class=doctop colspan=2>Method CreateVec:b2Mat22(c1:b2Vec2, c2:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Constructs the matrix using columns.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAngle>
<tr><td class=doctop colspan=2>Method GetAngle:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the angle.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetInverse>
<tr><td class=doctop colspan=2>Method GetInverse:b2Mat22()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Computes the inverse of this matrix, such that inv(A) * A = identity.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetAngle>
<tr><td class=doctop colspan=2>Method SetAngle(angle:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Initialize this matrix using an angle.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This matrix becomes an orthonormal rotation matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetIdentity>
<tr><td class=doctop colspan=2>Method SetIdentity()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set this to the identity matrix.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetZero>
<tr><td class=doctop colspan=2>Method SetZero()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set this matrix to all zeros.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2MouseJoint>
<tr><td class=doctop colspan=2>Type b2MouseJoint Extends b2Joint</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A mouse joint is used to make a point on a body track a specified world point.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This a soft constraint with a maximum force. This allows the constraint to stretch and without applying huge forces.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2MouseJoint_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetAnchor1>GetAnchor1</a></td><td class=docright>
Get the anchor point on body1 in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetAnchor2>GetAnchor2</a></td><td class=docright>
Get the anchor point on body2 in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalAnchor>GetLocalAnchor</a></td><td class=docright>
Returns the local anchor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReactionForce>GetReactionForce</a></td><td class=docright>
Get the reaction force on body2 at the joint anchor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReactionTorque>GetReactionTorque</a></td><td class=docright>
Get the reaction torque on body2.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetTarget>GetTarget</a></td><td class=docright>
Returns the target point.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetTarget>SetTarget</a></td><td class=docright>
Use this to update the target point.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAnchor1>
<tr><td class=doctop colspan=2>Method GetAnchor1:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the anchor point on body1 in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAnchor2>
<tr><td class=doctop colspan=2>Method GetAnchor2:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the anchor point on body2 in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalAnchor>
<tr><td class=doctop colspan=2>Method GetLocalAnchor:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the local anchor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReactionForce>
<tr><td class=doctop colspan=2>Method GetReactionForce:b2Vec2(inv_dt:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the reaction force on body2 at the joint anchor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReactionTorque>
<tr><td class=doctop colspan=2>Method GetReactionTorque:Float(inv_dt:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the reaction torque on body2.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetTarget>
<tr><td class=doctop colspan=2>Method GetTarget:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the target point.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetTarget>
<tr><td class=doctop colspan=2>Method SetTarget(target:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Use this to update the target point.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2MouseJointDef>
<tr><td class=doctop colspan=2>Type b2MouseJointDef Extends b2JointDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Mouse joint definition.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This requires a world target point, tuning parameters, and the time step.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2MouseJointDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetDampingRatio>GetDampingRatio</a></td><td class=docright>
Returns the damping ratio.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetFrequencyHz>GetFrequencyHz</a></td><td class=docright>
Returns the response speed.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMaxForce>GetMaxForce</a></td><td class=docright>
Returns the maximum constraint force that can be exerted to move the candidate body.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetTarget>GetTarget</a></td><td class=docright>
Returns the initial world target point.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetDampingRatio>SetDampingRatio</a></td><td class=docright>
The damping ratio.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFrequencyHz>SetFrequencyHz</a></td><td class=docright>
The response speed.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMaxForce>SetMaxForce</a></td><td class=docright>
The maximum constraint force that can be exerted to move the candidate body.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetTarget>SetTarget</a></td><td class=docright>
The initial world target point.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetDampingRatio>
<tr><td class=doctop colspan=2>Method GetDampingRatio:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the damping ratio.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetFrequencyHz>
<tr><td class=doctop colspan=2>Method GetFrequencyHz:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the response speed.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMaxForce>
<tr><td class=doctop colspan=2>Method GetMaxForce:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the maximum constraint force that can be exerted to move the candidate body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetTarget>
<tr><td class=doctop colspan=2>Method GetTarget:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the initial world target point.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetDampingRatio>
<tr><td class=doctop colspan=2>Method SetDampingRatio(ratio:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The damping ratio.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>0 = no damping, 1 = critical damping.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetFrequencyHz>
<tr><td class=doctop colspan=2>Method SetFrequencyHz(frequency:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The response speed.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMaxForce>
<tr><td class=doctop colspan=2>Method SetMaxForce(maxForce:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The maximum constraint force that can be exerted to move the candidate body.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Usually you will express as some multiple of the weight (multiplier * mass * gravity).</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetTarget>
<tr><td class=doctop colspan=2>Method SetTarget(target:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The initial world target point.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This is assumed to coincide with the body anchor initially.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2OBB>
<tr><td class=doctop colspan=2>Type b2OBB</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>An oriented bounding box.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2OBB_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetCenter>GetCenter</a></td><td class=docright>
Returns the local centroid.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetExtents>GetExtents</a></td><td class=docright>
Returns the half-widths.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetRotationMatrix>GetRotationMatrix</a></td><td class=docright>
Returns the rotation matrix.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetCenter>
<tr><td class=doctop colspan=2>Method GetCenter:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the local centroid.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetExtents>
<tr><td class=doctop colspan=2>Method GetExtents:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the half-widths.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetRotationMatrix>
<tr><td class=doctop colspan=2>Method GetRotationMatrix:b2Mat22()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the rotation matrix.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2PolygonDef>
<tr><td class=doctop colspan=2>Type b2PolygonDef Extends b2ShapeDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convex polygon.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Vertices must be in CCW order.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2PolygonDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetVertices>GetVertices</a></td><td class=docright>
Gets the polygon vertices in local coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetAsBox>SetAsBox</a></td><td class=docright>
Build vertices to represent an axis-aligned box.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetAsOrientedBox>SetAsOrientedBox</a></td><td class=docright>
Build vertices to represent an oriented box.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetVertices>SetVertices</a></td><td class=docright>
Sets the polygon vertices in local coordinates.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetVertices>
<tr><td class=doctop colspan=2>Method GetVertices:b2Vec2[]()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Gets the polygon vertices in local coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetAsBox>
<tr><td class=doctop colspan=2>Method SetAsBox(hx:Float, hy:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Build vertices to represent an axis-aligned box.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>hx </b> : the half-width.</li>
<li><b>hy </b> : the half-height. </li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetAsOrientedBox>
<tr><td class=doctop colspan=2>Method SetAsOrientedBox(hx:Float, hy:Float, center:b2Vec2, angle:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Build vertices to represent an oriented box.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Parameters:
<ul>
<li><b>hx </b> : the half-width.</li>
<li><b>hy </b> : the half-height. </li>
<li><b>center </b> : the center of the box in local coordinates. </li>
<li><b>angle </b> : the rotation of the box in local coordinates. </li>
</ul></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetVertices>
<tr><td class=doctop colspan=2>Method SetVertices(vertices:b2Vec2[])</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the polygon vertices in local coordinates.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2PolygonShape>
<tr><td class=doctop colspan=2>Type b2PolygonShape Extends b2Shape</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A convex polygon.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2PolygonShape_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Centroid>Centroid</a></td><td class=docright>
Get the centroid and apply the supplied transform.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetCentroid>GetCentroid</a></td><td class=docright>
Get local centroid relative to the parent body.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetCoreVertices>GetCoreVertices</a></td><td class=docright>
Get the core vertices in local coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetFirstVertex>GetFirstVertex</a></td><td class=docright>
Get the first vertex and apply the supplied transform.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetNormals>GetNormals</a></td><td class=docright>
Get the edge normal vectors.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetOBB>GetOBB</a></td><td class=docright>
Get the oriented bounding box relative to the parent body.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetVertexCount>GetVertexCount</a></td><td class=docright>
Get the vertex count.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetVertices>GetVertices</a></td><td class=docright>
Get the vertices in local coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#Support>Support</a></td><td class=docright>
Get the support point in the given world direction.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Centroid>
<tr><td class=doctop colspan=2>Method Centroid:b2Vec2(xf:b2XForm)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the centroid and apply the supplied transform.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetCentroid>
<tr><td class=doctop colspan=2>Method GetCentroid:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get local centroid relative to the parent body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetCoreVertices>
<tr><td class=doctop colspan=2>Method GetCoreVertices:b2Vec2[]()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the core vertices in local coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetFirstVertex>
<tr><td class=doctop colspan=2>Method GetFirstVertex:b2Vec2(xf:b2XForm)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the first vertex and apply the supplied transform.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetNormals>
<tr><td class=doctop colspan=2>Method GetNormals:b2Vec2[]()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the edge normal vectors.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>There is one for each vertex.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetOBB>
<tr><td class=doctop colspan=2>Method GetOBB:b2OBB()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the oriented bounding box relative to the parent body.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetVertexCount>
<tr><td class=doctop colspan=2>Method GetVertexCount:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the vertex count.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetVertices>
<tr><td class=doctop colspan=2>Method GetVertices:b2Vec2[]()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the vertices in local coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Support>
<tr><td class=doctop colspan=2>Method Support:b2Vec2(xf:b2XForm, d:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the support point in the given world direction.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2PrismaticJoint>
<tr><td class=doctop colspan=2>Type b2PrismaticJoint Extends b2Joint</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2PrismaticJoint_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#EnableLimit>EnableLimit</a></td><td class=docright>
Enable/disable the joint limit.
</td></tr>
<tr><td class=docleft width=1%><a href=#EnableMotor>EnableMotor</a></td><td class=docright>
Enable/disable the joint motor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetAnchor1>GetAnchor1</a></td><td class=docright>
Get the anchor point on body1 in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetAnchor2>GetAnchor2</a></td><td class=docright>
Get the anchor point on body2 in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetJointSpeed>GetJointSpeed</a></td><td class=docright>
Get the current joint translation speed, usually in meters per second.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetJointTranslation>GetJointTranslation</a></td><td class=docright>
Get the current joint translation, usually in meters.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLowerLimit>GetLowerLimit</a></td><td class=docright>
Get the lower joint limit, usually in meters.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMotorForce>GetMotorForce</a></td><td class=docright>
Get the current motor force, usually in N.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMotorSpeed>GetMotorSpeed</a></td><td class=docright>
Get the motor speed, usually in meters per second.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReactionForce>GetReactionForce</a></td><td class=docright>
Get the reaction force on body2 at the joint anchor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReactionTorque>GetReactionTorque</a></td><td class=docright>
Get the reaction torque on body2.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetUpperLimit>GetUpperLimit</a></td><td class=docright>
Get the upper joint limit, usually in meters.
</td></tr>
<tr><td class=docleft width=1%><a href=#IsLimitEnabled>IsLimitEnabled</a></td><td class=docright>
Is the joint limit enabled?
</td></tr>
<tr><td class=docleft width=1%><a href=#IsMotorEnabled>IsMotorEnabled</a></td><td class=docright>
Is the joint motor enabled?
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLimits>SetLimits</a></td><td class=docright>
Set the joint limits, usually in meters.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMaxMotorForce>SetMaxMotorForce</a></td><td class=docright>
Set the maximum motor force, usually in N.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMotorSpeed>SetMotorSpeed</a></td><td class=docright>
Set the motor speed, usually in meters per second.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=EnableLimit>
<tr><td class=doctop colspan=2>Method EnableLimit(flag:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enable/disable the joint limit.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=EnableMotor>
<tr><td class=doctop colspan=2>Method EnableMotor(flag:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enable/disable the joint motor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAnchor1>
<tr><td class=doctop colspan=2>Method GetAnchor1:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the anchor point on body1 in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAnchor2>
<tr><td class=doctop colspan=2>Method GetAnchor2:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the anchor point on body2 in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetJointSpeed>
<tr><td class=doctop colspan=2>Method GetJointSpeed:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the current joint translation speed, usually in meters per second.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetJointTranslation>
<tr><td class=doctop colspan=2>Method GetJointTranslation:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the current joint translation, usually in meters.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLowerLimit>
<tr><td class=doctop colspan=2>Method GetLowerLimit:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the lower joint limit, usually in meters.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMotorForce>
<tr><td class=doctop colspan=2>Method GetMotorForce:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the current motor force, usually in N.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMotorSpeed>
<tr><td class=doctop colspan=2>Method GetMotorSpeed:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the motor speed, usually in meters per second.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReactionForce>
<tr><td class=doctop colspan=2>Method GetReactionForce:b2Vec2(inv_dt:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the reaction force on body2 at the joint anchor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReactionTorque>
<tr><td class=doctop colspan=2>Method GetReactionTorque:Float(inv_dt:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the reaction torque on body2.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetUpperLimit>
<tr><td class=doctop colspan=2>Method GetUpperLimit:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the upper joint limit, usually in meters.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsLimitEnabled>
<tr><td class=doctop colspan=2>Method IsLimitEnabled:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is the joint limit enabled?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsMotorEnabled>
<tr><td class=doctop colspan=2>Method IsMotorEnabled:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is the joint motor enabled?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLimits>
<tr><td class=doctop colspan=2>Method SetLimits(lowerLimit:Float, upperLimit:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the joint limits, usually in meters.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMaxMotorForce>
<tr><td class=doctop colspan=2>Method SetMaxMotorForce(force:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the maximum motor force, usually in N.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMotorSpeed>
<tr><td class=doctop colspan=2>Method SetMotorSpeed(speed:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the motor speed, usually in meters per second.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2PrismaticJointDef>
<tr><td class=doctop colspan=2>Type b2PrismaticJointDef Extends b2JointDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Prismatic joint definition.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This requires defining a line of motion using an axis and an anchor point. The definition uses local
anchor points and a local axis so that the initial configuration can violate the constraint slightly. The
joint translation is zero when the local anchor points coincide in world space. Using local anchors and a
local axis helps when saving and loading a game.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2PrismaticJointDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#EnableLimit>EnableLimit</a></td><td class=docright>
Enable/disable the joint limit.
</td></tr>
<tr><td class=docleft width=1%><a href=#EnableMotor>EnableMotor</a></td><td class=docright>
Enable/disable the joint motor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalAnchor1>GetLocalAnchor1</a></td><td class=docright>
Returns the local anchor point.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalAnchor2>GetLocalAnchor2</a></td><td class=docright>
Returns the local anchor point.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalAxis1>GetLocalAxis1</a></td><td class=docright>
Returns the local translation axis in body1.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLowerTranslation>GetLowerTranslation</a></td><td class=docright>
Returns the lower translation limit.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMaxMotorForce>GetMaxMotorForce</a></td><td class=docright>
Returns the maximum motor torque.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMotorSpeed>GetMotorSpeed</a></td><td class=docright>
The motorspeed, in degrees per second.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReferenceAngle>GetReferenceAngle</a></td><td class=docright>
Returns the constrained angle between the bodies.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetUpperTranslation>GetUpperTranslation</a></td><td class=docright>
Returns the upper translation limit.
</td></tr>
<tr><td class=docleft width=1%><a href=#Initialize>Initialize</a></td><td class=docright>
Initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.
</td></tr>
<tr><td class=docleft width=1%><a href=#IsLimitEnabled>IsLimitEnabled</a></td><td class=docright>
Returns True if the joint limit is enabled.
</td></tr>
<tr><td class=docleft width=1%><a href=#IsMotorEnabled>IsMotorEnabled</a></td><td class=docright>
Returns true if the joint motor is enabled.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLocalAnchor1>SetLocalAnchor1</a></td><td class=docright>
The local anchor point relative to body1's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLocalAnchor2>SetLocalAnchor2</a></td><td class=docright>
The local anchor point relative to body2's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLocalAxis1>SetLocalAxis1</a></td><td class=docright>
The local translation axis in body1.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLowerTranslation>SetLowerTranslation</a></td><td class=docright>
The lower translation limit, usually in meters.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMaxMotorForce>SetMaxMotorForce</a></td><td class=docright>
The maximum motor torque, usually in N-m.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMotorSpeed>SetMotorSpeed</a></td><td class=docright>
The desired motor speed in degrees per second.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetReferenceAngle>SetReferenceAngle</a></td><td class=docright>
The constrained angle between the bodies: body2_angle - body1_angle.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetUpperTranslation>SetUpperTranslation</a></td><td class=docright>
The upper translation limit, usually in meters.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=EnableLimit>
<tr><td class=doctop colspan=2>Method EnableLimit(value:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enable/disable the joint limit.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=EnableMotor>
<tr><td class=doctop colspan=2>Method EnableMotor(value:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enable/disable the joint motor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalAnchor1>
<tr><td class=doctop colspan=2>Method GetLocalAnchor1:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the local anchor point.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalAnchor2>
<tr><td class=doctop colspan=2>Method GetLocalAnchor2:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the local anchor point.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalAxis1>
<tr><td class=doctop colspan=2>Method GetLocalAxis1:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the local translation axis in body1.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLowerTranslation>
<tr><td class=doctop colspan=2>Method GetLowerTranslation:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the lower translation limit.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMaxMotorForce>
<tr><td class=doctop colspan=2>Method GetMaxMotorForce:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the maximum motor torque.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMotorSpeed>
<tr><td class=doctop colspan=2>Method GetMotorSpeed:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The motorspeed, in degrees per second.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReferenceAngle>
<tr><td class=doctop colspan=2>Method GetReferenceAngle:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the constrained angle between the bodies.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetUpperTranslation>
<tr><td class=doctop colspan=2>Method GetUpperTranslation:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the upper translation limit.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Initialize>
<tr><td class=doctop colspan=2>Method Initialize(body1:b2Body, body2:b2Body, anchor:b2Vec2, axis:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsLimitEnabled>
<tr><td class=doctop colspan=2>Method IsLimitEnabled:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns True if the joint limit is enabled.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsMotorEnabled>
<tr><td class=doctop colspan=2>Method IsMotorEnabled:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns true if the joint motor is enabled.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLocalAnchor1>
<tr><td class=doctop colspan=2>Method SetLocalAnchor1(anchor:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The local anchor point relative to body1's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLocalAnchor2>
<tr><td class=doctop colspan=2>Method SetLocalAnchor2(anchor:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The local anchor point relative to body2's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLocalAxis1>
<tr><td class=doctop colspan=2>Method SetLocalAxis1(axis:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The local translation axis in body1.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLowerTranslation>
<tr><td class=doctop colspan=2>Method SetLowerTranslation(translation:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The lower translation limit, usually in meters.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMaxMotorForce>
<tr><td class=doctop colspan=2>Method SetMaxMotorForce(force:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The maximum motor torque, usually in N-m.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMotorSpeed>
<tr><td class=doctop colspan=2>Method SetMotorSpeed(speed:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The desired motor speed in degrees per second.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetReferenceAngle>
<tr><td class=doctop colspan=2>Method SetReferenceAngle(angle:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The constrained angle between the bodies: body2_angle - body1_angle.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetUpperTranslation>
<tr><td class=doctop colspan=2>Method SetUpperTranslation(translation:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The upper translation limit, usually in meters.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2PulleyJoint>
<tr><td class=doctop colspan=2>Type b2PulleyJoint Extends b2Joint</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The pulley joint is connected to two bodies and two fixed ground points.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The pulley supports a ratio such that:
<pre>
length1 + ratio * length2 <= constant
</pre>
Yes, the force transmitted is scaled by the ratio. The pulley also enforces a maximum length limit on both sides.
This is useful to prevent one side of the pulley hitting the top.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2PulleyJoint_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetAnchor1>GetAnchor1</a></td><td class=docright>
Get the anchor point on body1 in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetAnchor2>GetAnchor2</a></td><td class=docright>
Get the anchor point on body2 in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetGroundAnchor1>GetGroundAnchor1</a></td><td class=docright>
Get the first ground anchor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetGroundAnchor2>GetGroundAnchor2</a></td><td class=docright>
Get the second ground anchor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLength1>GetLength1</a></td><td class=docright>
Get the current length of the segment attached to body1.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLength2>GetLength2</a></td><td class=docright>
Get the current length of the segment attached to body2.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetRatio>GetRatio</a></td><td class=docright>
Get the pulley ratio.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReactionForce>GetReactionForce</a></td><td class=docright>
Get the reaction force on body2 at the joint anchor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReactionTorque>GetReactionTorque</a></td><td class=docright>
Get the reaction torque on body2.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAnchor1>
<tr><td class=doctop colspan=2>Method GetAnchor1:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the anchor point on body1 in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAnchor2>
<tr><td class=doctop colspan=2>Method GetAnchor2:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the anchor point on body2 in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetGroundAnchor1>
<tr><td class=doctop colspan=2>Method GetGroundAnchor1:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the first ground anchor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetGroundAnchor2>
<tr><td class=doctop colspan=2>Method GetGroundAnchor2:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the second ground anchor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLength1>
<tr><td class=doctop colspan=2>Method GetLength1:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the current length of the segment attached to body1.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLength2>
<tr><td class=doctop colspan=2>Method GetLength2:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the current length of the segment attached to body2.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetRatio>
<tr><td class=doctop colspan=2>Method GetRatio:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the pulley ratio.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReactionForce>
<tr><td class=doctop colspan=2>Method GetReactionForce:b2Vec2(inv_dt:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the reaction force on body2 at the joint anchor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReactionTorque>
<tr><td class=doctop colspan=2>Method GetReactionTorque:Float(inv_dt:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the reaction torque on body2.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2PulleyJointDef>
<tr><td class=doctop colspan=2>Type b2PulleyJointDef Extends b2JointDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Pulley joint definition.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This requires two ground anchors, two dynamic body anchor points, max lengths for each side, and a pulley ratio.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2PulleyJointDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetGroundAnchor1>GetGroundAnchor1</a></td><td class=docright>
Returns the first ground anchor, in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetGroundAnchor2>GetGroundAnchor2</a></td><td class=docright>
Returns the second ground anchor, in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLength1>GetLength1</a></td><td class=docright>
Returns the reference length for the segment attached to body1.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLength2>GetLength2</a></td><td class=docright>
Returns the reference length for the segment attached to body2.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalAnchor1>GetLocalAnchor1</a></td><td class=docright>
Returns the local anchor point.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalAnchor2>GetLocalAnchor2</a></td><td class=docright>
Returns the local anchor point.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMaxLength1>GetMaxLength1</a></td><td class=docright>
Returns the maximum length of the segment attached to body1.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMaxLength2>GetMaxLength2</a></td><td class=docright>
Returns the maximum length of the segment attached to body2.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetRatio>GetRatio</a></td><td class=docright>
Returns the pulley ratio.
</td></tr>
<tr><td class=docleft width=1%><a href=#Initialize>Initialize</a></td><td class=docright>
Initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetGroundAnchor1>SetGroundAnchor1</a></td><td class=docright>
The first ground anchor in world coordinates. This point never moves.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetGroundAnchor2>SetGroundAnchor2</a></td><td class=docright>
The second ground anchor in world coordinates. This point never moves.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLength1>SetLength1</a></td><td class=docright>
The a reference length for the segment attached to body1.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLength2>SetLength2</a></td><td class=docright>
The a reference length for the segment attached to body2.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLocalAnchor1>SetLocalAnchor1</a></td><td class=docright>
The local anchor point relative to body1's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLocalAnchor2>SetLocalAnchor2</a></td><td class=docright>
The local anchor point relative to body2's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMaxLength1>SetMaxLength1</a></td><td class=docright>
The maximum length of the segment attached to body1.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMaxLength2>SetMaxLength2</a></td><td class=docright>
The maximum length of the segment attached to body2.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetRatio>SetRatio</a></td><td class=docright>
The pulley ratio, used to simulate a block-and-tackle.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetGroundAnchor1>
<tr><td class=doctop colspan=2>Method GetGroundAnchor1:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the first ground anchor, in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetGroundAnchor2>
<tr><td class=doctop colspan=2>Method GetGroundAnchor2:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the second ground anchor, in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLength1>
<tr><td class=doctop colspan=2>Method GetLength1:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the reference length for the segment attached to body1.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLength2>
<tr><td class=doctop colspan=2>Method GetLength2:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the reference length for the segment attached to body2.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalAnchor1>
<tr><td class=doctop colspan=2>Method GetLocalAnchor1:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the local anchor point.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalAnchor2>
<tr><td class=doctop colspan=2>Method GetLocalAnchor2:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the local anchor point.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMaxLength1>
<tr><td class=doctop colspan=2>Method GetMaxLength1:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the maximum length of the segment attached to body1.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMaxLength2>
<tr><td class=doctop colspan=2>Method GetMaxLength2:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the maximum length of the segment attached to body2.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetRatio>
<tr><td class=doctop colspan=2>Method GetRatio:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the pulley ratio.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Initialize>
<tr><td class=doctop colspan=2>Method Initialize(body1:b2Body, body2:b2Body, groundAnchor1:b2Vec2, groundAnchor2:b2Vec2, anchor1:b2Vec2, anchor2:b2Vec2, ratio:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetGroundAnchor1>
<tr><td class=doctop colspan=2>Method SetGroundAnchor1(anchor:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The first ground anchor in world coordinates. This point never moves.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetGroundAnchor2>
<tr><td class=doctop colspan=2>Method SetGroundAnchor2(anchor:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The second ground anchor in world coordinates. This point never moves.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLength1>
<tr><td class=doctop colspan=2>Method SetLength1(length:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The a reference length for the segment attached to body1.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLength2>
<tr><td class=doctop colspan=2>Method SetLength2(length:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The a reference length for the segment attached to body2.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLocalAnchor1>
<tr><td class=doctop colspan=2>Method SetLocalAnchor1(anchor:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The local anchor point relative to body1's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLocalAnchor2>
<tr><td class=doctop colspan=2>Method SetLocalAnchor2(anchor:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The local anchor point relative to body2's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMaxLength1>
<tr><td class=doctop colspan=2>Method SetMaxLength1(maxLength:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The maximum length of the segment attached to body1.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMaxLength2>
<tr><td class=doctop colspan=2>Method SetMaxLength2(maxLength:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The maximum length of the segment attached to body2.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetRatio>
<tr><td class=doctop colspan=2>Method SetRatio(ratio:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The pulley ratio, used to simulate a block-and-tackle.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2RevoluteJoint>
<tr><td class=doctop colspan=2>Type b2RevoluteJoint Extends b2Joint</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A revolute joint constrains to bodies to share a common point while they are free to rotate about the point.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The relative rotation about the shared point is the joint angle. You can limit the relative rotation
with a joint limit that specifies a lower and upper angle. You can use a motor to drive the relative rotation
about the shared point. A maximum motor torque is provided so that infinite forces are not generated.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2RevoluteJoint_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#EnableLimit>EnableLimit</a></td><td class=docright>
Enable/disable the joint limit.
</td></tr>
<tr><td class=docleft width=1%><a href=#EnableMotor>EnableMotor</a></td><td class=docright>
Enable/disable the joint motor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetAnchor1>GetAnchor1</a></td><td class=docright>
Get the anchor point on body1 in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetAnchor2>GetAnchor2</a></td><td class=docright>
Get the anchor point on body2 in world coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetJointAngle>GetJointAngle</a></td><td class=docright>
Get the current joint angle in degrees.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetJointSpeed>GetJointSpeed</a></td><td class=docright>
Get the current joint angle speed in degrees per second.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLowerLimit>GetLowerLimit</a></td><td class=docright>
Get the lower joint limit in degrees.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMotorSpeed>GetMotorSpeed</a></td><td class=docright>
Get the motor speed in radians per second.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMotorTorque>GetMotorTorque</a></td><td class=docright>
Get the current motor torque, usually in N-m.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReactionForce>GetReactionForce</a></td><td class=docright>
Get the reaction force on body2 at the joint anchor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReactionTorque>GetReactionTorque</a></td><td class=docright>
Get the reaction torque on body2.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetUpperLimit>GetUpperLimit</a></td><td class=docright>
Get the upper joint limit in degrees.
</td></tr>
<tr><td class=docleft width=1%><a href=#IsLimitEnabled>IsLimitEnabled</a></td><td class=docright>
Is the joint limit enabled?
</td></tr>
<tr><td class=docleft width=1%><a href=#IsMotorEnabled>IsMotorEnabled</a></td><td class=docright>
Is the joint motor enabled?
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLimits>SetLimits</a></td><td class=docright>
Set the joint limits in degrees.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMaxMotorTorque>SetMaxMotorTorque</a></td><td class=docright>
Set the maximum motor torque, usually in N-m.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMotorSpeed>SetMotorSpeed</a></td><td class=docright>
Set the motor speed in radians per second.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=EnableLimit>
<tr><td class=doctop colspan=2>Method EnableLimit(flag:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enable/disable the joint limit.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=EnableMotor>
<tr><td class=doctop colspan=2>Method EnableMotor(flag:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enable/disable the joint motor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAnchor1>
<tr><td class=doctop colspan=2>Method GetAnchor1:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the anchor point on body1 in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetAnchor2>
<tr><td class=doctop colspan=2>Method GetAnchor2:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the anchor point on body2 in world coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetJointAngle>
<tr><td class=doctop colspan=2>Method GetJointAngle:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the current joint angle in degrees.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetJointSpeed>
<tr><td class=doctop colspan=2>Method GetJointSpeed:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the current joint angle speed in degrees per second.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLowerLimit>
<tr><td class=doctop colspan=2>Method GetLowerLimit:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the lower joint limit in degrees.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMotorSpeed>
<tr><td class=doctop colspan=2>Method GetMotorSpeed:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the motor speed in radians per second.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMotorTorque>
<tr><td class=doctop colspan=2>Method GetMotorTorque:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the current motor torque, usually in N-m.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReactionForce>
<tr><td class=doctop colspan=2>Method GetReactionForce:b2Vec2(inv_dt:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the reaction force on body2 at the joint anchor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReactionTorque>
<tr><td class=doctop colspan=2>Method GetReactionTorque:Float(inv_dt:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the reaction torque on body2.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetUpperLimit>
<tr><td class=doctop colspan=2>Method GetUpperLimit:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the upper joint limit in degrees.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsLimitEnabled>
<tr><td class=doctop colspan=2>Method IsLimitEnabled:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is the joint limit enabled?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsMotorEnabled>
<tr><td class=doctop colspan=2>Method IsMotorEnabled:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is the joint motor enabled?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLimits>
<tr><td class=doctop colspan=2>Method SetLimits(lowerLimit:Float, upperLimit:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the joint limits in degrees.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMaxMotorTorque>
<tr><td class=doctop colspan=2>Method SetMaxMotorTorque(torque:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the maximum motor torque, usually in N-m.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMotorSpeed>
<tr><td class=doctop colspan=2>Method SetMotorSpeed(speed:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the motor speed in radians per second.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2RevoluteJointDef>
<tr><td class=doctop colspan=2>Type b2RevoluteJointDef Extends b2JointDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Revolute joint definition.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This requires defining an anchor point where the bodies are joined. The definition uses local anchor points
so that the initial configuration can violate the constraint slightly. You also need to specify the initial
relative angle for joint limits. This helps when saving and loading a game. The local anchor points are measured
from the body's origin rather than the center of mass because: 1. you might not know where the center of mass
will be. 2. if you add/remove shapes from a body and recompute the mass, the joints will be broken.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2RevoluteJointDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#EnableLimit>EnableLimit</a></td><td class=docright>
Enables joint limits.
</td></tr>
<tr><td class=docleft width=1%><a href=#EnableMotor>EnableMotor</a></td><td class=docright>
Enables the joint motor.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalAnchor1>GetLocalAnchor1</a></td><td class=docright>
The local anchor point relative to body1's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLocalAnchor2>GetLocalAnchor2</a></td><td class=docright>
The local anchor point relative to body2's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetLowerAngle>GetLowerAngle</a></td><td class=docright>
The lower angle for the joint limit (degrees).
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMaxMotorTorque>GetMaxMotorTorque</a></td><td class=docright>
The maximum motor torque used to achieve the desired motor speed, usually in N-m.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetMotorSpeed>GetMotorSpeed</a></td><td class=docright>
The desired motor speed, usually in degrees per second.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetReferenceAngle>GetReferenceAngle</a></td><td class=docright>
The body2 angle minus body1 angle in the reference state (degrees).
</td></tr>
<tr><td class=docleft width=1%><a href=#GetUpperAngle>GetUpperAngle</a></td><td class=docright>
The upper angle for the joint limit (degrees).
</td></tr>
<tr><td class=docleft width=1%><a href=#Initialize>Initialize</a></td><td class=docright>
Initialize the bodies, anchors, and reference angle using the world anchor.
</td></tr>
<tr><td class=docleft width=1%><a href=#IsLimitEnabled>IsLimitEnabled</a></td><td class=docright>
A flag to enable joint limits.
</td></tr>
<tr><td class=docleft width=1%><a href=#IsMotorEnabled>IsMotorEnabled</a></td><td class=docright>
A flag to enable the joint motor.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLocalAnchor1>SetLocalAnchor1</a></td><td class=docright>
Sets the local anchor point relative to body1's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLocalAnchor2>SetLocalAnchor2</a></td><td class=docright>
Sets the local anchor point relative to body2's origin.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetLowerAngle>SetLowerAngle</a></td><td class=docright>
Sets the lower angle for the joint limit (degrees).
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMaxMotorTorque>SetMaxMotorTorque</a></td><td class=docright>
Sets the maximum motor torque used to achieve the desired motor speed, usually in N-m.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMotorSpeed>SetMotorSpeed</a></td><td class=docright>
Sets the desired motor speed, usually in degrees per second.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetReferenceAngle>SetReferenceAngle</a></td><td class=docright>
Sets the body2 angle minus body1 angle in the reference state (degrees).
</td></tr>
<tr><td class=docleft width=1%><a href=#SetUpperAngle>SetUpperAngle</a></td><td class=docright>
Sets the upper angle for the joint limit (degrees).
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=EnableLimit>
<tr><td class=doctop colspan=2>Method EnableLimit(limit:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enables joint limits.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=EnableMotor>
<tr><td class=doctop colspan=2>Method EnableMotor(value:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enables the joint motor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalAnchor1>
<tr><td class=doctop colspan=2>Method GetLocalAnchor1:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The local anchor point relative to body1's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLocalAnchor2>
<tr><td class=doctop colspan=2>Method GetLocalAnchor2:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The local anchor point relative to body2's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetLowerAngle>
<tr><td class=doctop colspan=2>Method GetLowerAngle:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The lower angle for the joint limit (degrees).</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMaxMotorTorque>
<tr><td class=doctop colspan=2>Method GetMaxMotorTorque:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The maximum motor torque used to achieve the desired motor speed, usually in N-m.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMotorSpeed>
<tr><td class=doctop colspan=2>Method GetMotorSpeed:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The desired motor speed, usually in degrees per second.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetReferenceAngle>
<tr><td class=doctop colspan=2>Method GetReferenceAngle:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The body2 angle minus body1 angle in the reference state (degrees).</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetUpperAngle>
<tr><td class=doctop colspan=2>Method GetUpperAngle:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The upper angle for the joint limit (degrees).</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Initialize>
<tr><td class=doctop colspan=2>Method Initialize(body1:b2Body, body2:b2Body, anchor:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Initialize the bodies, anchors, and reference angle using the world anchor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsLimitEnabled>
<tr><td class=doctop colspan=2>Method IsLimitEnabled:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A flag to enable joint limits.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsMotorEnabled>
<tr><td class=doctop colspan=2>Method IsMotorEnabled:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A flag to enable the joint motor.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLocalAnchor1>
<tr><td class=doctop colspan=2>Method SetLocalAnchor1(anchor:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the local anchor point relative to body1's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLocalAnchor2>
<tr><td class=doctop colspan=2>Method SetLocalAnchor2(anchor:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the local anchor point relative to body2's origin.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetLowerAngle>
<tr><td class=doctop colspan=2>Method SetLowerAngle(angle:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the lower angle for the joint limit (degrees).</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMaxMotorTorque>
<tr><td class=doctop colspan=2>Method SetMaxMotorTorque(torque:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the maximum motor torque used to achieve the desired motor speed, usually in N-m.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMotorSpeed>
<tr><td class=doctop colspan=2>Method SetMotorSpeed(speed:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the desired motor speed, usually in degrees per second.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetReferenceAngle>
<tr><td class=doctop colspan=2>Method SetReferenceAngle(angle:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the body2 angle minus body1 angle in the reference state (degrees).</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetUpperAngle>
<tr><td class=doctop colspan=2>Method SetUpperAngle(angle:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the upper angle for the joint limit (degrees).</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2Segment>
<tr><td class=doctop colspan=2>Type b2Segment</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A line segment.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2Segment_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Creates a new b2Segment object.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateXY>CreateXY</a></td><td class=docright>
Creates a new b2Segment object.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetEndPoint>GetEndPoint</a></td><td class=docright>
Returns the end point of this segment.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetStartPoint>GetStartPoint</a></td><td class=docright>
Returns the start point of this segment.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetEndPoint>SetEndPoint</a></td><td class=docright>
Sets the end point of this segment.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetStartPoint>SetStartPoint</a></td><td class=docright>
Sets the start point of this segment.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Method Create:b2Segment(p1:b2Vec2 = Null, p2:b2Vec2 = Null)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a new b2Segment object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CreateXY>
<tr><td class=doctop colspan=2>Method CreateXY:b2Segment(x1:Float, y1:Float, x2:Float, y2:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a new b2Segment object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetEndPoint>
<tr><td class=doctop colspan=2>Method GetEndPoint:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the end point of this segment.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetStartPoint>
<tr><td class=doctop colspan=2>Method GetStartPoint:b2Vec2()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the start point of this segment.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetEndPoint>
<tr><td class=doctop colspan=2>Method SetEndPoint(point:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the end point of this segment.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetStartPoint>
<tr><td class=doctop colspan=2>Method SetStartPoint(point:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the start point of this segment.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2Shape>
<tr><td class=doctop colspan=2>Type b2Shape</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A shape is used for collision detection.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Shapes are created in b2World. You can use shape for collision detection before they are attached to the world.
<p>
Warning: You cannot reuse shapes.
</p></td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2Shape_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#ComputeAABB>ComputeAABB</a></td><td class=docright>
Given a transform, compute the associated axis aligned bounding box for this shape.
</td></tr>
<tr><td class=docleft width=1%><a href=#ComputeMass>ComputeMass</a></td><td class=docright>
Compute the mass properties of this shape using its dimensions and density.
</td></tr>
<tr><td class=docleft width=1%><a href=#ComputeSweptAABB>ComputeSweptAABB</a></td><td class=docright>
Given two transforms, compute the associated swept axis aligned bounding box for this shape.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetBody>GetBody</a></td><td class=docright>
Get the parent body of this shape.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetFilterData>GetFilterData</a></td><td class=docright>
Get the contact filtering data.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetFriction>GetFriction</a></td><td class=docright>
Get the coefficient of friction.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetNext>GetNext</a></td><td class=docright>
Get the next shape in the parent body's shape list.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetRestitution>GetRestitution</a></td><td class=docright>
Get the coefficient of restitution.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetSweepRadius>GetSweepRadius</a></td><td class=docright>
Get the maximum radius about the parent body's center of mass.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetUserData>GetUserData</a></td><td class=docright>
Get the user data that was assigned in the shape definition.
</td></tr>
<tr><td class=docleft width=1%><a href=#IsSensor>IsSensor</a></td><td class=docright>
Is this shape a sensor (non-solid)?
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFilterData>SetFilterData</a></td><td class=docright>
Set the contact filtering data.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFriction>SetFriction</a></td><td class=docright>
Set the coefficient of friction.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetRestitution>SetRestitution</a></td><td class=docright>
Set the coefficient of restitution.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetUserData>SetUserData</a></td><td class=docright>
Sets the user data.
</td></tr>
<tr><td class=docleft width=1%><a href=#TestPoint>TestPoint</a></td><td class=docright>
Test a point for containment in this shape.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=ComputeAABB>
<tr><td class=doctop colspan=2>Method ComputeAABB(aabb:b2AABB, xf:b2XForm)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Given a transform, compute the associated axis aligned bounding box for this shape.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=ComputeMass>
<tr><td class=doctop colspan=2>Method ComputeMass(data:b2MassData)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>the mass data for this shape.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Compute the mass properties of this shape using its dimensions and density.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The inertia tensor is computed about the local origin, not the centroid.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=ComputeSweptAABB>
<tr><td class=doctop colspan=2>Method ComputeSweptAABB(aabb:b2AABB, xf1:b2XForm, xf2:b2XForm)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Given two transforms, compute the associated swept axis aligned bounding box for this shape.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetBody>
<tr><td class=doctop colspan=2>Method GetBody:b2Body()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the parent body of this shape.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetFilterData>
<tr><td class=doctop colspan=2>Method GetFilterData:b2FilterData()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the contact filtering data.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetFriction>
<tr><td class=doctop colspan=2>Method GetFriction:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the coefficient of friction.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetNext>
<tr><td class=doctop colspan=2>Method GetNext:b2Shape()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the next shape in the parent body's shape list.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetRestitution>
<tr><td class=doctop colspan=2>Method GetRestitution:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the coefficient of restitution.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetSweepRadius>
<tr><td class=doctop colspan=2>Method GetSweepRadius:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the maximum radius about the parent body's center of mass.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetUserData>
<tr><td class=doctop colspan=2>Method GetUserData:Object()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the user data that was assigned in the shape definition.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsSensor>
<tr><td class=doctop colspan=2>Method IsSensor:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Is this shape a sensor (non-solid)?</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetFilterData>
<tr><td class=doctop colspan=2>Method SetFilterData(data:b2FilterData)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the contact filtering data.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>You must call b2World::Refilter to correct existing contacts/non-contacts.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetFriction>
<tr><td class=doctop colspan=2>Method SetFriction(friction:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the coefficient of friction.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetRestitution>
<tr><td class=doctop colspan=2>Method SetRestitution(restitution:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set the coefficient of restitution.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetUserData>
<tr><td class=doctop colspan=2>Method SetUserData(data:Object)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the user data.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=TestPoint>
<tr><td class=doctop colspan=2>Method TestPoint:Int(xf:b2XForm, p:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Test a point for containment in this shape.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This only works for convex shapes.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2ShapeDef>
<tr><td class=doctop colspan=2>Type b2ShapeDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A shape definition is used to construct a shape.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>You can reuse shape definitions safely.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2ShapeDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetDensity>GetDensity</a></td><td class=docright>
Gets the shape's density, usually in kg/m^2.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetFilter>GetFilter</a></td><td class=docright>
Returns the contact filtering data.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetFriction>GetFriction</a></td><td class=docright>
Gets the shape's friction coefficient, usually in the range [0,1].
</td></tr>
<tr><td class=docleft width=1%><a href=#GetRestitution>GetRestitution</a></td><td class=docright>
Gets the shape's restitution (elasticity) usually in the range [0,1].
</td></tr>
<tr><td class=docleft width=1%><a href=#IsSensor>IsSensor</a></td><td class=docright>
Returns True if this shape is a sensor.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetDensity>SetDensity</a></td><td class=docright>
Sets the shape's density, usually in kg/m^2.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFilter>SetFilter</a></td><td class=docright>
Sets the contact filtering data.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFriction>SetFriction</a></td><td class=docright>
Sets the shape's friction coefficient, usually in the range [0,1].
</td></tr>
<tr><td class=docleft width=1%><a href=#SetIsSensor>SetIsSensor</a></td><td class=docright>
A sensor shape collects contact information but never generates a collision response.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetRestitution>SetRestitution</a></td><td class=docright>
Sets the shape's restitution (elasticity) usually in the range [0,1].
</td></tr>
<tr><td class=docleft width=1%><a href=#SetUserData>SetUserData</a></td><td class=docright>
Sets the user data.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetDensity>
<tr><td class=doctop colspan=2>Method GetDensity:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Gets the shape's density, usually in kg/m^2.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetFilter>
<tr><td class=doctop colspan=2>Method GetFilter:b2FilterData()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the contact filtering data.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetFriction>
<tr><td class=doctop colspan=2>Method GetFriction:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Gets the shape's friction coefficient, usually in the range [0,1].</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetRestitution>
<tr><td class=doctop colspan=2>Method GetRestitution:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Gets the shape's restitution (elasticity) usually in the range [0,1].</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=IsSensor>
<tr><td class=doctop colspan=2>Method IsSensor:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns True if this shape is a sensor.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>A sensor shape collects contact information but never generates a collision response.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetDensity>
<tr><td class=doctop colspan=2>Method SetDensity(density:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the shape's density, usually in kg/m^2.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetFilter>
<tr><td class=doctop colspan=2>Method SetFilter(filter:b2FilterData)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the contact filtering data.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetFriction>
<tr><td class=doctop colspan=2>Method SetFriction(friction:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the shape's friction coefficient, usually in the range [0,1].</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetIsSensor>
<tr><td class=doctop colspan=2>Method SetIsSensor(sensor:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A sensor shape collects contact information but never generates a collision response.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetRestitution>
<tr><td class=doctop colspan=2>Method SetRestitution(restitution:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the shape's restitution (elasticity) usually in the range [0,1].</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetUserData>
<tr><td class=doctop colspan=2>Method SetUserData(data:Object)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the user data.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2TensorDampingController>
<tr><td class=doctop colspan=2>Type b2TensorDampingController Extends b2Controller</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Applies top down linear damping to the controlled bodies.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The damping is calculated by multiplying velocity by a matrix in local co-ordinates.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2TensorDampingController_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetMaxTimestep>GetMaxTimestep</a></td><td class=docright>
Returns the maximum amount of damping.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetTensor>GetTensor</a></td><td class=docright>
Returns the tensor to use in damping model.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMaxTimestep>SetMaxTimestep</a></td><td class=docright>
Set this to a positive number to clamp the maximum amount of damping done.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetTensor>SetTensor</a></td><td class=docright>
Sets the tensor to use in damping model.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMaxTimestep>
<tr><td class=doctop colspan=2>Method GetMaxTimestep:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the maximum amount of damping.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetTensor>
<tr><td class=doctop colspan=2>Method GetTensor:b2Mat22()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the tensor to use in damping model.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMaxTimestep>
<tr><td class=doctop colspan=2>Method SetMaxTimestep(timestep:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set this to a positive number to clamp the maximum amount of damping done.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetTensor>
<tr><td class=doctop colspan=2>Method SetTensor(tensor:b2Mat22)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the tensor to use in damping model.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Some examples (matrixes in format (row1; row2) )
<table>
<th><td>Matrix</td><td>Description</td></th>
<tr><td>(-a 0;0 -a)</td><td>Standard isotropic damping with strength a</td></tr>
<tr><td>(0 a;-a 0)</td><td>Electron in fixed field - a force at right angles to velocity with proportional magnitude</td></tr>
<tr><td>(-a 0;0 -b)</td><td>Differing x and y damping. Useful e.g. for top-down wheels.</td></tr>
</table>
<p>
By the way, tensor in this case just means matrix, don't let the terminology get you down.
</p></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2TensorDampingControllerDef>
<tr><td class=doctop colspan=2>Type b2TensorDampingControllerDef Extends b2ControllerDef</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Used to build tensor damping controllers.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2TensorDampingControllerDef_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#GetMaxTimestep>GetMaxTimestep</a></td><td class=docright>
Returns the maximum amount of damping.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetTensor>GetTensor</a></td><td class=docright>
Returns the tensor to use in damping model.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetAxisAligned>SetAxisAligned</a></td><td class=docright>
Sets damping independently along the x and y axes.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetMaxTimestep>SetMaxTimestep</a></td><td class=docright>
Set this to a positive number to clamp the maximum amount of damping done.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetTensor>SetTensor</a></td><td class=docright>
Sets the tensor to use in damping model.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetMaxTimestep>
<tr><td class=doctop colspan=2>Method GetMaxTimestep:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the maximum amount of damping.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetTensor>
<tr><td class=doctop colspan=2>Method GetTensor:b2Mat22()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the tensor to use in damping model.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetAxisAligned>
<tr><td class=doctop colspan=2>Method SetAxisAligned(xDamping:Float, yDamping:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets damping independently along the x and y axes.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetMaxTimestep>
<tr><td class=doctop colspan=2>Method SetMaxTimestep(timestep:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Set this to a positive number to clamp the maximum amount of damping done.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetTensor>
<tr><td class=doctop colspan=2>Method SetTensor(tensor:b2Mat22)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the tensor to use in damping model.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Some examples (matrixes in format (row1; row2) )
<table>
<th><td>Matrix</td><td>Description</td></th>
<tr><td>(-a 0;0 -a)</td><td>Standard isotropic damping with strength a</td></tr>
<tr><td>(0 a;-a 0)</td><td>Electron in fixed field - a force at right angles to velocity with proportional magnitude</td></tr>
<tr><td>(-a 0;0 -b)</td><td>Differing x and y damping. Useful e.g. for top-down wheels.</td></tr>
</table>
<p>
By the way, tensor in this case just means matrix, don't let the terminology get you down.
</p></td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2Vec2>
<tr><td class=doctop colspan=2>Type b2Vec2</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A 2D column vector.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2Vec2_globals></a>Globals Summary</th></tr><tr><td colspan=2>
<a href=#ZERO>ZERO</a>
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2Vec2_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Add>Add</a></td><td class=docright>
Adds <b>vec</b> to this vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Copy>Copy</a></td><td class=docright>
Copies <b>vec</b> into this object.
</td></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Creates a new vector with the given coordinates.
</td></tr>
<tr><td class=docleft width=1%><a href=#Divide>Divide</a></td><td class=docright>
Divides the vector by <b>value</b>.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetX>GetX</a></td><td class=docright>
Returns the X coordinate.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetY>GetY</a></td><td class=docright>
Returns the Y coordinate.
</td></tr>
<tr><td class=docleft width=1%><a href=#Length>Length</a></td><td class=docright>
Returns the length of this vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#LengthSquared>LengthSquared</a></td><td class=docright>
Get the length squared.
</td></tr>
<tr><td class=docleft width=1%><a href=#Multiply>Multiply</a></td><td class=docright>
Multiplies the vector by <b>value</b>.
</td></tr>
<tr><td class=docleft width=1%><a href=#Normalize>Normalize</a></td><td class=docright>
Convert this vector into a unit vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#Plus>Plus</a></td><td class=docright>
Adds <b>vec</b> to this vector, returning the a new b2Vec2.
</td></tr>
<tr><td class=docleft width=1%><a href=#Set>Set</a></td><td class=docright>
Sets the x and y parts.
</td></tr>
<tr><td class=docleft width=1%><a href=#Subtract>Subtract</a></td><td class=docright>
Subtracts <b>vec</b> from this object, returning a new b2Vec2.
</td></tr>
<tr><td class=docleft width=1%><a href=#X>X</a></td><td class=docright>
Returns the X coordinate.
</td></tr>
<tr><td class=docleft width=1%><a href=#Y>Y</a></td><td class=docright>
Returns the Y coordinate.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2Vec2_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CreateVec2>CreateVec2</a></td><td class=docright>
Creates a new vector with the given coordinates.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=ZERO>
<tr><td class=doctop colspan=2>Global ZERO:b2Vec2</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A zero vector (0,0)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Add>
<tr><td class=doctop colspan=2>Method Add(vec:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Adds <b>vec</b> to this vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Copy>
<tr><td class=doctop colspan=2>Method Copy(vec:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Copies <b>vec</b> into this object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Method Create:b2Vec2(x:Float = 0, y:Float = 0)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a new vector with the given coordinates.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Divide>
<tr><td class=doctop colspan=2>Method Divide:b2Vec2(value:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Divides the vector by <b>value</b>.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetX>
<tr><td class=doctop colspan=2>Method GetX:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the X coordinate.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetY>
<tr><td class=doctop colspan=2>Method GetY:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the Y coordinate.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Length>
<tr><td class=doctop colspan=2>Method Length:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the length of this vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=LengthSquared>
<tr><td class=doctop colspan=2>Method LengthSquared:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the length squared.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>For performance, use this instead of b2Vec2::Length (if possible).</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Multiply>
<tr><td class=doctop colspan=2>Method Multiply:b2Vec2(value:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Multiplies the vector by <b>value</b>.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Normalize>
<tr><td class=doctop colspan=2>Method Normalize:Float()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The length.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Convert this vector into a unit vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Plus>
<tr><td class=doctop colspan=2>Method Plus:b2Vec2(vec:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Adds <b>vec</b> to this vector, returning the a new b2Vec2.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This object is not modified.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Set>
<tr><td class=doctop colspan=2>Method Set(x:Float, y:Float)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Sets the x and y parts.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Subtract>
<tr><td class=doctop colspan=2>Method Subtract:b2Vec2(vec:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Subtracts <b>vec</b> from this object, returning a new b2Vec2.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This object is not modified.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=X>
<tr><td class=doctop colspan=2>Method X:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the X coordinate.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Y>
<tr><td class=doctop colspan=2>Method Y:Float()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Returns the Y coordinate.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CreateVec2>
<tr><td class=doctop colspan=2>Function CreateVec2:b2Vec2(x:Float = 0, y:Float = 0)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Creates a new vector with the given coordinates.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2World>
<tr><td class=doctop colspan=2>Type b2World</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The world type manages all physics entities, dynamic simulation, and asynchronous queries.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The world also contains efficient memory management facilities.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2World_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
Construct a world object.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateBody>CreateBody</a></td><td class=docright>
Create a rigid body given a definition.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateController>CreateController</a></td><td class=docright>
Add a controller to the world.
</td></tr>
<tr><td class=docleft width=1%><a href=#CreateJoint>CreateJoint</a></td><td class=docright>
Create a joint to constrain bodies together.
</td></tr>
<tr><td class=docleft width=1%><a href=#DestroyBody>DestroyBody</a></td><td class=docright>
Destroy a rigid body given a definition.
</td></tr>
<tr><td class=docleft width=1%><a href=#DestroyController>DestroyController</a></td><td class=docright>
Removes a controller from the world.
</td></tr>
<tr><td class=docleft width=1%><a href=#DestroyJoint>DestroyJoint</a></td><td class=docright>
Destroy a joint.
</td></tr>
<tr><td class=docleft width=1%><a href=#DoStep>DoStep</a></td><td class=docright>
Take a time Step.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetBodyCount>GetBodyCount</a></td><td class=docright>
Get the number of bodies.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetBodyList>GetBodyList</a></td><td class=docright>
Get the world body list.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetGroundBody>GetGroundBody</a></td><td class=docright>
The world provides a single static ground body with no collision shapes.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetJointCount>GetJointCount</a></td><td class=docright>
Get the number joints.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetJointList>GetJointList</a></td><td class=docright>
Get the world joint list.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetPairCount>GetPairCount</a></td><td class=docright>
Get the number of broad-phase pairs.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetProxyCount>GetProxyCount</a></td><td class=docright>
Get the number of broad-phase proxies.
</td></tr>
<tr><td class=docleft width=1%><a href=#InRange>InRange</a></td><td class=docright>
Check if the AABB is within the broadphase limits.
</td></tr>
<tr><td class=docleft width=1%><a href=#Query>Query</a></td><td class=docright>
Query the world for all shapes that potentially overlap the provided AABB.
</td></tr>
<tr><td class=docleft width=1%><a href=#Raycast>Raycast</a></td><td class=docright>
Query the world for all shapes that intersect a given segment.
</td></tr>
<tr><td class=docleft width=1%><a href=#RaycastOne>RaycastOne</a></td><td class=docright>
Performs a raycast as with Raycast, finding the first intersecting shape.
</td></tr>
<tr><td class=docleft width=1%><a href=#Refilter>Refilter</a></td><td class=docright>
Re-filter a shape.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetBoundaryListener>SetBoundaryListener</a></td><td class=docright>
Register a broad-phase boundary listener.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetContactListener>SetContactListener</a></td><td class=docright>
Register a contact event listener.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetContinuousPhysics>SetContinuousPhysics</a></td><td class=docright>
Enable/disable continuous physics. For testing.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetDebugDraw>SetDebugDraw</a></td><td class=docright>
Register a routine for debug drawing.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetDestructionListener>SetDestructionListener</a></td><td class=docright>
Register a destruction listener.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetFilter>SetFilter</a></td><td class=docright>
Register a contact filter to provide specific control over collision.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetGravity>SetGravity</a></td><td class=docright>
Change the global gravity vector.
</td></tr>
<tr><td class=docleft width=1%><a href=#SetWarmStarting>SetWarmStarting</a></td><td class=docright>
Enable/disable warm starting. For testing.
</td></tr>
<tr><td class=docleft width=1%><a href=#Validate>Validate</a></td><td class=docright>
Perform validation of internal data structures.
</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2World_functions></a>Functions Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CreateWorld>CreateWorld</a></td><td class=docright>
Construct a world object.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Method Create:b2World(worldAABB:b2AABB, gravity:b2Vec2, doSleep:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Construct a world object.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CreateBody>
<tr><td class=doctop colspan=2>Method CreateBody:b2Body(def:b2BodyDef)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a rigid body given a definition.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>No reference to the definition is retained.
<p>
Warning: This method is locked during callbacks.
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CreateController>
<tr><td class=doctop colspan=2>Method CreateController:b2Controller(def:b2ControllerDef)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Add a controller to the world.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CreateJoint>
<tr><td class=doctop colspan=2>Method CreateJoint:b2Joint(def:b2JointDef)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Create a joint to constrain bodies together.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>No reference to the definition is retained. This may cause the connected bodies to cease
colliding.
<p>
Warning: This method is locked during callbacks.
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=DestroyBody>
<tr><td class=doctop colspan=2>Method DestroyBody(body:b2Body)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Destroy a rigid body given a definition.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>No reference to the definition is retained.
<p>
Warning: This automatically deletes all associated shapes and joints.
</p>
<p>
Warning: This method is locked during callbacks.
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=DestroyController>
<tr><td class=doctop colspan=2>Method DestroyController(controller:b2Controller)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Removes a controller from the world.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=DestroyJoint>
<tr><td class=doctop colspan=2>Method DestroyJoint(joint:b2Joint)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Destroy a joint.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This may cause the connected bodies to begin colliding.
<p>
Warning: This method is locked during callbacks.
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=DoStep>
<tr><td class=doctop colspan=2>Method DoStep(timeStep:Float, velocityIterations:Int, positionIterations:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Take a time Step.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This performs collision detection, integration, and constraint solution.
<p>Parameters:
<ul>
<li><b> timeStep </b> : the amount of time To simulate, this should Not vary. </li>
<li><b> velocityIterations </b> : for the velocity constraint solver.</li>
<li><b> positionIterations </b> : for the position constraint solver.</li>
</ul>
</p></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetBodyCount>
<tr><td class=doctop colspan=2>Method GetBodyCount:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the number of bodies.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetBodyList>
<tr><td class=doctop colspan=2>Method GetBodyList:b2Body()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The head of the world body list.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the world body list.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>With the returned body, use b2Body::GetNext to get the next body in the world list. A NULL body indicates
the end of the list.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetGroundBody>
<tr><td class=doctop colspan=2>Method GetGroundBody:b2Body()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>The world provides a single static ground body with no collision shapes.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>You can use this to simplify the creation of joints and static shapes.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetJointCount>
<tr><td class=doctop colspan=2>Method GetJointCount:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the number joints.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetJointList>
<tr><td class=doctop colspan=2>Method GetJointList:b2Joint()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The head of the world joint list.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the world joint list.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>With the returned joint, use b2Joint::GetNext to get the next joint in the world list. A NULL joint indicates
the end of the list.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetPairCount>
<tr><td class=doctop colspan=2>Method GetPairCount:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the number of broad-phase pairs.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetProxyCount>
<tr><td class=doctop colspan=2>Method GetProxyCount:Int()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get the number of broad-phase proxies.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=InRange>
<tr><td class=doctop colspan=2>Method InRange:Int(aabb:b2AABB)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Check if the AABB is within the broadphase limits.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Query>
<tr><td class=doctop colspan=2>Method Query:Int(aabb:b2AABB, shapes:b2Shape[])</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The number of shapes found in aabb.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Query the world for all shapes that potentially overlap the provided AABB.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>You provide a shape array for populating. The number of shapes found is returned.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Raycast>
<tr><td class=doctop colspan=2>Method Raycast:Int(segment:b2Segment, shapes:b2Shape[], solidShapes:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Query the world for all shapes that intersect a given segment.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>You provide a shape array of an appropriate size. The number of shapes found is returned, and the array
is filled in order of intersection.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=RaycastOne>
<tr><td class=doctop colspan=2>Method RaycastOne:b2Shape(segment:b2Segment, lambda:Float Var, normal:b2Vec2, solidShapes:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Performs a raycast as with Raycast, finding the first intersecting shape.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Refilter>
<tr><td class=doctop colspan=2>Method Refilter(shape:b2Shape)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Re-filter a shape.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>This re-runs contact filtering on a shape.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetBoundaryListener>
<tr><td class=doctop colspan=2>Method SetBoundaryListener(listener:b2BoundaryListener)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Register a broad-phase boundary listener.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetContactListener>
<tr><td class=doctop colspan=2>Method SetContactListener(listener:b2ContactListener)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Register a contact event listener.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetContinuousPhysics>
<tr><td class=doctop colspan=2>Method SetContinuousPhysics(flag:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enable/disable continuous physics. For testing.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetDebugDraw>
<tr><td class=doctop colspan=2>Method SetDebugDraw(debugDraw:b2DebugDraw)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Register a routine for debug drawing.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>The debug draw functions are called inside the b2World::DoStep method, so make sure your renderer is ready to
consume draw commands when you call DoStep().</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetDestructionListener>
<tr><td class=doctop colspan=2>Method SetDestructionListener(listener:b2DestructionListener)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Register a destruction listener.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetFilter>
<tr><td class=doctop colspan=2>Method SetFilter(_filter:b2ContactFilter)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Register a contact filter to provide specific control over collision.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Otherwise the default filter is used.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetGravity>
<tr><td class=doctop colspan=2>Method SetGravity(gravity:b2Vec2)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Change the global gravity vector.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetWarmStarting>
<tr><td class=doctop colspan=2>Method SetWarmStarting(flag:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Enable/disable warm starting. For testing.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Validate>
<tr><td class=doctop colspan=2>Method Validate()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Perform validation of internal data structures.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CreateWorld>
<tr><td class=doctop colspan=2>Function CreateWorld:b2World(worldAABB:b2AABB, gravity:b2Vec2, doSleep:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Construct a world object.</td></tr>
</table>
<br>
<table class=doc width=100% cellspacing=3 id=b2XForm>
<tr><td class=doctop colspan=2>Type b2XForm</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>A transform contains translation and rotation.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>It is used to represent the position and orientation of rigid frames.</td></tr>
</table>
<table class=doc width=90% align=center><tr ><th class=doctop colspan=2 align=left><a name=b2XForm_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#Create>Create</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#GetPosition>GetPosition</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#GetR>GetR</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#SetPosition>SetPosition</a></td><td class=docright>
&nbsp;
</td></tr>
<tr><td class=docleft width=1%><a href=#SetR>SetR</a></td><td class=docright>
&nbsp;
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=Create>
<tr><td class=doctop colspan=2>Method Create:b2XForm()</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetPosition>
<tr><td class=doctop colspan=2>Method GetPosition:b2Vec2()</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetR>
<tr><td class=doctop colspan=2>Method GetR:b2Mat22()</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetPosition>
<tr><td class=doctop colspan=2>Method SetPosition(pos:b2Vec2)</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SetR>
<tr><td class=doctop colspan=2>Method SetR(r:b2Mat22)</td></tr>
</table>
<br>
<h2 id=modinfo>Module Information</h2>
<table width=100%>
<tr><th width=1%>Version</th><td>1.04</td></tr>
<tr><th width=1%>License</th><td>MIT</td></tr>
<tr><th width=1%>Copyright</th><td>Box2D (c) 2006-2008 Erin Catto http://www.gphysics.com</td></tr>
<tr><th width=1%>Copyright</th><td>BlitzMax port - 2008-2009 Bruce A Henderson</td></tr>
<tr><th width=1%>History</th><td>1.04</td></tr>
<tr><th width=1%>History</th><td>Updated to box2d svn (rev 207)</td></tr>
<tr><th width=1%>History</th><td>Added b2LineJoint type.</td></tr>
<tr><th width=1%>History</th><td>Added b2ShapeDef.SetUserData() method.</td></tr>
<tr><th width=1%>History</th><td>Added b2Mat22.GetAngle() method.</td></tr>
<tr><th width=1%>History</th><td>Added b2Mat22 Create... methods, and others.</td></tr>
<tr><th width=1%>History</th><td>Added shape SetFriction() and SetRestitution() methods.</td></tr>
<tr><th width=1%>History</th><td>Fixed contact filter example and docs.</td></tr>
<tr><th width=1%>History</th><td>Added b2EdgeShape type.</td></tr>
<tr><th width=1%>History</th><td>Added staticedges, dynamicedges, pyramidstaticedges and buoyancy examples.</td></tr>
<tr><th width=1%>History</th><td>Added buoyancy types + methods.</td></tr>
<tr><th width=1%>History</th><td>Added b2Body SetMass() method.</td></tr>
<tr><th width=1%>History</th><td>Added b2BodyDef GetMassData() method.</td></tr>
<tr><th width=1%>History</th><td>Converted bool handling in glue to use ints instead.</td></tr>
<tr><th width=1%>History</th><td>1.03</td></tr>
<tr><th width=1%>History</th><td>Updated to box2d svn (rev 172)</td></tr>
<tr><th width=1%>History</th><td>Added b2CircleShape and b2PolygonShape types.</td></tr>
<tr><th width=1%>History</th><td>Added b2OBB type.</td></tr>
<tr><th width=1%>History</th><td>Added b2Segment type.</td></tr>
<tr><th width=1%>History</th><td>Added b2World Raycast(), RaycastOne() and InRange() methods.</td></tr>
<tr><th width=1%>History</th><td>Added b2Body.GetWorld() method.</td></tr>
<tr><th width=1%>History</th><td>Added raycast example.</td></tr>
<tr><th width=1%>History</th><td>1.02</td></tr>
<tr><th width=1%>History</th><td>Updated to box2d svn (rev 169)</td></tr>
<tr><th width=1%>History</th><td>API CHANGES : DoStep() - changed iteration parameters</td></tr>
<tr><th width=1%>History</th><td>API CHANGES : joints - GetReactionForce() And GetReactionTorque() added 'dt' parameter.</td></tr>
<tr><th width=1%>History</th><td>Added car example.</td></tr>
<tr><th width=1%>History</th><td>Added revolute example.</td></tr>
<tr><th width=1%>History</th><td>Added b2ShapeDef - SetIsSensor and IsSensor methods.</td></tr>
<tr><th width=1%>History</th><td>Fixed typo in b2ContactListener - Remove().</td></tr>
<tr><th width=1%>History</th><td>Added b2World.Refilter() and several missing b2Shape methods.</td></tr>
<tr><th width=1%>History</th><td>Updated Documentation.</td></tr>
<tr><th width=1%>History</th><td>1.01</td></tr>
<tr><th width=1%>History</th><td>Fixed filterdata problem. Fixed collisionfiltering example.</td></tr>
<tr><th width=1%>History</th><td>Added Theo Jansen example.</td></tr>
<tr><th width=1%>History</th><td>1.00 Initial Release</td></tr>
</body></html>
